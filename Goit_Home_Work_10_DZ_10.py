# ===================  Home work 10 ========================

# +++++++++++++++++++++++++++++  Основи роботи з класами # Об'єктноорієнтоване програмування (ООП) ++++++++++++++++++++++++++++++++++++++

#                     1. Визначення та створення класу
#                     2. Створення об'єктів
#                     3. Атрибути класу (поля та методи)
#                     4. Конструктор класу
#                     5. Наслідування
#                     6. Method Resolution Order (MRO).
#                     7. Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString).
#                     8. Власні винятки
#                     9. Поліморфізм / Качина типізація


# ================================ Звдання 1 / Task 1 ======================================

# ================================  Визначення та створення класу. ==========================

# Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, 
# називають об'єктноорієнтованою парадигмою програмування.
# Об'єктноорієнтоване програмування (ООП) по праву вважається однією з найефективніших методологій створення програмних продуктів.
# Ви пишете класи, що описують реально чинні предмети та ситуації, а потім створюєте об'єкти на основі цих описів.

# Покажемо найпростіший клас на наступному прикладі.

# class Person:
#     pass  # Порожній блок


# p = Person()
# Ми створюємо новий клас за допомогою оператора class та імені класу. За цим слідує блок виразів, 
# що формують тіло класу. В нашому випадку блок у нас порожній, на що вказує оператор pass.
# Далі ми створюємо об'єкт-екземпляр класу, записуючи ім'я класу з дужками.

# ООП має чотири основні концепції, які відрізняють його від інших методологій програмування:

# Абстракція
# Інкапсуляція
# Наслідування
# Поліформізм
# З чотирьох концепцій ми розберемо у завданнях три останні, крім абстракції. 
# Це більш просунута категорія, і створення абстрактних класів ми розглядатимемо в другому блоці навчання. 
# Зараз нагадаю йде перший блок Python. Коротко тільки зауважимо, що:

# Абстракція - це модель якогось об'єкта або явища з реального світу, що відкидає незначні деталі, 
# які не грають істотну роль в цьому контексті.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. 
# Також створіть екземпляр класу Animal (замість реалізації класу можете використовувати pass) і привласніть змінній animal.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
#    pass        # якщо в реалізації класу є тільки оператор *pass - то це пустий клас. Реалізація класу - це як код оголошення функції , 
#                # Починається після двокрапки з нового рядка і з відступом в табуляцію або 4 пробіли. 

# animal = Animal() # зміній *animal присвоюємо пустий екземпляр класу *Animal 


# ================================ Звдання 2 / Task 2 ======================================

# ================================   Створення об'єктів ==========================

# Об'єкти можуть зберігати дані у звичайних змінних, які належать об'єкту. 
# Змінні, що належать об'єкту або класу, називають полями. Об'єкти можуть мати функції, які належать класу. 
# Такі функції називають методами класу. Всі разом (поля та методи) заведено називати атрибутами класу.

# За допомогою атрибутів класу ми виконуємо інкапсуляцію — приховуємо деталі реалізації під інтерфейсом класу.

# Інкапсуляція — це здатність об'єктів приховувати частину свого стану та поведінки від інших об'єктів, 
# надаючи зовнішньому світу лише певний інтерфейс взаємодії із собою.

# Методи класу мають одну відмінність від звичайних функцій: вони повинні мати додатково ім'я, 
# яке додається до початку списку параметрів. 
# Однак, при виклику методу ніякого значення цьому параметру привласнювати не потрібно його вкаже Python. 
# Ця змінна вказує на сам об'єкт екземпляра класу, і за традицією вона називається self.

# class Person:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def greeting(self):
#         return f"Hi {self.name}"


# p = Person("Boris", 34)
# Метод __init__() - спеціальний метод, 
# який автоматично виконується під час створення кожного нового екземпляра на базі класу Person (конструктор). 
# Ім'я методу починається та закінчується двома символами підкреслення. 
# Причина у тому, що так ми запобігаємо конфліктам імен стандартних методів Python і методів ваших класів.

# Коли ми створюємо екземпляр Person, Python викликає метод __init__() з класу Person. 
# Ми передаємо в Person() ім'я "Boris" та вік 34 як аргументи. 
# Значення self буде передано автоматично, явно передавати його не потрібно.

# Зверніть увагу, що метод класу greeting не приймає параметрів, проте має параметр self у визначенні функції.



# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. Також створіть екземпляр класу Animal та привласніть змінній animal.
# Для класу Animal у конструкторі створіть дві властивості: nickname - кличка тварини та 
# weight - вага тварини. Реалізуйте також метод класу say. 
# При реалізації методу можна використати оператор pass, поки що головне - це визначення, а не конкретна реалізація.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
   
#    def __init__ (self, nickname, weight): # Конструктор (це функція імя якої починається і закінчується з подвійних підкреслень) 
#                                            # Першим аргументом конструктора завжди є зміна *self, далі може йти довільна кількість аргументів.
#                                            # Оголошення всіх довільних аргументів починається завжти зміною *self.
#         self.nickname = nickname # Оголошення *nickname  #Оголошення аргументів конструктора відбувається через зміну *self.
#         self.weight = weight     # Оголошення *weight  #Оголошення аргументів конструктора відбувається через зміну *self.

#    def say(self):  # Створення методу класу . імя методу класу не починається з подвійного підкреслення 
#                    # та викликається через крапку в тілі коду (приклад animal.say(*якесь_занчення)),
#                                        
#       pass         # В нашому випадку реалізуєм пустий метод . Тому в тілі методу використовуємо тільки оператор *pass який приймає один аргумент довільного типу.
#                    # Оператор *pass - ігнорує код в блоці в якому заданий . Використовуємо для ігнорування частини коду логіка якого ще непрописана. 
#                    # Щоб інтерпритатор Python не видавав помилок при запуску цього блоку коду .   
               

# animal = Animal("Linda", 25) # зміній *animal присвоюємо обєкт(*екземпляр_класу) *Animal який містить два заданих  аргумента. 
#                             #  Animal("Linda", 25) де # *Animal - це імя класу . 
#                                                       # *"Linda" - заданий  аргумент *nickname *class Animal
#                                                       # *25 - заданий аргумент *weight *class Animal 


# ================================ Звдання 3 / Task 3  ======================================

# ================================   Атрибути класу (поля та методи) ==========================

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для попереднього завдання реалізуйте в класі Animal метод change_weight, який має змінювати вагу тварини.

# Викличте функцію change_weight(12) для об'єкта animal та змініть значення початкової ваги з 10 на 12 одиниць.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal: # Оголошення власного класу з іменем  *Animal 
#               # клас може містити поля та методи, поля це зміні в класі, методи це описані функції в класі, 
#               # Методи є двох типів :
#                                 # Методи класу (описуються в контструкторі) і
#                                 # методи обєків (описуються в інших функціях класу) Тобо *підметод(власне визначення:) )
    
#     def __init__(self, nickname, weight): # Конструктор класу в якому задаємо методи класу *class Animal
#         self.nickname = nickname          # Оголошення методу класу *nickname  #Оголошення аргументів конструктора відбувається через зміну *self.
#         self.weight = weight              # Оголошення методу класу *weight  #Оголошення аргументів конструктора відбувається через зміну *self 

#     def say(self): # Пустий метод обєекту
#         pass

#     def change_weight(self, vaga): # Оголошення методу *change_weight для обєкту *weight, *class Animal
#         self.weight = vaga         # Присвоюємо значення *vaga , яке буде отримане з методу *change_weight , полю *self.weight класу *class Animal 
         
        

# animal = Animal("Simon", 10) # змінії *animal присвоюємо екземпляр(обєкт) класу *Animal("Simon", 10) 
#                              # з визначеними значеннями полів *nickname ="Simon" , *weight = 10
# print(animal)

# animal.change_weight(12)      # стверений метод *.change_weight(12) - змінить  поточне значення поля *weight в екземплярі *animal
#                               # де *.change_weight(12)- власний метод обєкта *weight з значенням аргумета *12, 
#                               # а  *animal - зміна що містить екземпляр створеного класу *class Animal. # *animal = *<__main__.Animal object at 0x0000017DC20BA780>
                             
# simon_weight = animal.weight  # Повертаємо в *simon_weight значення поля *weight за допомогою створеного методу каласу *.weight для *class Anima  # *simon_weight == 12 для нашого прикладу

# print(simon_weight)    # Принтимо результат # *12


# ================================ Звдання 4 / Task 4  ======================================

# ================================   Конструктор класу ==========================

# Існує два типи полів: змінні класи та змінні об'єкта. Як видно з назви вони відрізняються тим, 
# що належать або класу чи об'єкту відповідно.

# Змінні класу – доступ до них мають усі екземпляри цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, 
# коли змінює змінну класу, змінює її для решти екземплярів цього ж класу.

# Змінні об'єкта - належать кожному окремому екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, 
# тобто вона жодним чином не пов'язана з іншими такими ж полями в інших екземплярах.

# Розглянемо наступний приклад:

# class Person:
#     count = 0

#     def __init__(self, name):
#         self.name = name
#         Person.count += 1

#     def how_many_persons(self):
#         print(f"Кількість людей зараз {Person.count}")


# first = Person('Boris')
# first.how_many_persons()
# second = Person('Alex')
# first.how_many_persons()
# Вивід:

# Кількість людей зараз 1
# Кількість людей зараз 2
# Тут count належить класу Person і є змінною класу. 
# Змінна name належить об'єкту та є змінною об'єкта, і надається значення за допомогою self. 
# Як бачимо з прикладу, звернення до змінної класу Person виконується як Person.count, 
# і ми не використовуємо звернення self.count. До змінної ж об'єкта name, у всіх методах цього об'єкта, 
# ми звертаємось за допомогою позначення self.name.

# Але якщо ми введемо змінну об'єкта з тим самим ім'ям, що й змінну класу, це зробить недоступною змінну класу!

# class Person:
#     count = 0

#     def __init__(self):
#         pass


# person = Person()
# print(person.count)  # 0
# Ми ще маємо доступ до змінної класу, а у наступному прикладі вже ні.

# class Person:
#     count = 0

#     def __init__(self):
#         self.count = 10


# person = Person()
# print(person.count)  # 10
# Примітка
# Але ми все ще маємо доступ до змінної через ім'я класу: `Person.count`




# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Додамо в клас Animal змінну класу color, значення якої спочатку дорівнює 'white', і метод change_color, 
# який повинен змінювати значення змінної класу color.

# Створіть екземпляри об'єкта: first_animal та second_animal

# Викличте функцію change_color("red") для будь-якого екземпляра об'єкту Animal та змініть значення змінної класу color на "red".

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:

#     color = "white" # не обовязкове значення поля *color для всіх екзеплярів класу *class_Animal, по замовчуванню задано "white".
#                     # Це "прихована" змінна методу класу ,  не є обовязковою бо неоголошенна в конструкторі *__init__ 
#                     # В самому екзеплярі її значення ні побачити, ні задати , ні змінити напряму не можливо. 
#                     # ЇЇ значення можна повернути методом класу *.color і воно буде одинаковим для всіх екземплярів.
#                     # Зміна значення зміної класу відбувається в середені реалізації класу , за наступною схемою :
#                     # *Імя_класу.*зміна_класу = *зміна_що_містить_значення_яке_хочимо_присвоїти. 
#             # Приклад: Animal.color = new_animal_color *(ДЛЯ НАШОГО ВИПАДКУ)
#                     # Для заміни її значення зовні,  потрібно створювати окремий метод , в якому і будемо робити переприсвоєння . 
#                     # Після заміни значення, воно буде одинаковим для всіх екзеплярів цього класу, 
#                     # тобто не потрібно його міняти для кожного екзепляра цього класу і відповідно не можливо всатновити окремо її значення для окремого екземпляра цього класу.
#                     # Дививсь нижче , оголошення методу *change_color(self, new_animal_color): - там і будемо мінти це значення.
#             # Для нашого прикладу: # екзепляр *first_animal.color - поверне *white і *second_animal.color поверне також *white
#                                    # Після застосовуння методу *.change_color("red") до хоча б одного екземпляра(*second_animal.change_color("red"))
#                                    # стане  *first_animal.color - поверне *red і *second_animal.color поверне *red                 

#     def __init__(self, nickname, weight): # Конструкор класу *class_Animal , вньому оголошуємо обовязкові поля для заданого класу.
#         self.nickname = nickname   # Створення поля *self.nickname класу *class_Animal,
#                                    # Такий запис означає що перше значення в екземплярі буде містити значення поля *nickname
#                                    # Це дозволяє для нашого екзепляра застосувати метод класу *.nickname щоб отримати його значення.
#             # Для нашого прикладу: екзепляр *first_animal.nickname - поверне *Simon , а *second_animal.nickname поверне *Murzyk
        
        
#         self.weight = weight       # Створення поля *self.weight класу *class_Animal,
#                                    # Такий запис означає що друге значення в екземплярі буде містити значення поля *weight
#                                    # Це дозволяє для нашого екзепляра застосувати метод класу *.weight щоб отримати його значення.
#             # Для нашого прикладу: екзепляр *first_animal.weight - поверне *10, а *second_animal.nickname поверне *12        

#     def say(self):  # .say(self) - оголошення пустого методу класу ,(приклад що так можна робити, реалізацію методу можна буде дописати за потреби)
#         pass

#     def change_weight(self, weight): # Оголошення методу *.change_weight(weight) для зміни поля *weight в нашому класі *class_Animal,
#                                      # Метод приймає один аргумент і міняє поле *weight в екземплярі до якого застосовується на
#                                      # на значення аргументу що передається в методі в круглих дужках (*значення_на яке_хочемо_змінити_поле)
        
#         self.weight = weight         # Такий запис означає що полю екземпляра *self.weight -
#                                      # присвоїти значення *weight передане з методу *.change_weight(weight)
    
#     def change_color(self, new_animal_color): # Метод який буде міняти значення поля *color класу , на значення передане методом *.change_color(*якесь_значення)
#         Animal.color = new_animal_color       # такий запис міняє значення поля(зміної) класу , на значення яке передасть метод *.change_color(*якесь_значення)
#         return new_animal_color               # Повертаємо змінене значення з класу. 
#                                 # Приклад : # Після застосовуння методу *.change_color("red") до хоча б одного екземпляра(*second_animal.change_color("red"))
#                                             # стане  *first_animal.color - поверне *red і *second_animal.color поверне *red  

# # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# first_animal = Animal("Simon", 10,)  # Створення екземляру *first_animal з заданими полями *nickname і *weight
# second_animal = Animal("Murzyk", 12) # Створення екземляру *second_animal з заданими полями *nickname і *weight

# print(first_animal.color, second_animal.color ) # Принт для контролю результату # Виведе *white *white

# second_animal.change_color("red")  # Застосування методу *.change_color("red") до екземпляру *second_animal

# print(first_animal.color, second_animal.color ) # Принт для контролю результату, після застосування методу *.change_color("red") 
#                                                 # Виведе *red *red

# ================================ Звдання 5 / Task 5  ======================================

# ================================    Наслідування класу. Поліморфізм ==========================

# Основна сила об'єктно-орієнтованого програмування полягає саме в можливості успадкування класів. 
# Успадкування дає можливість створювати нові класи, що містять атрибути батьківських класів.
# Поліморфізм - це здатність програми вибирати різні реалізації при виклику операцій з однією і тією ж назвою.
# Тобто при виклику методу say в екземпляра класу Cat викликається нова реалізація, а не успадкована від класу Animal

# class Human:
#     name = ''

#     def voice(self):
#         print(f"Hello! My name is {self.name}")


# class Developer(Human):
#     field_description = "My Programming language"
#     language = ""

#     def make_some_code(self):
#         return f"{self.field_description} is {self.value}"


# class PythonDeveloper(Developer):
#     value = "Python"


# class JSDeveloper(Developer):
#     value = "JavaScript"


# p_dev = PythonDeveloper()
# p_dev.name = 'Bob'
# p_dev.voice()  # Hello! My name is Bob
# p_dev.make_some_code()  # My Programming language is Python

# js_dev = JSDeveloper()
# js_dev.make_some_code()  # My Programming language is JavaScript
# У цьому прикладі ми створили батьківський клас Human, який визначив, що у всіх є ім'я та метод voice.

# Далі ми розширили функціонал класу Human та створили клас Developer, 
# який успадковується від Human і додає йому поля field_description та language і метод make_some_code. 
# І щоб реалізувати функціонал розробника конкретною мовою, ми зробили два класи PythonDeveloper та JSDeveloper. 
# Тепер якщо ми захочемо додати функціонал у всі дочірні для Human класи, 
# то для цього можна додати потрібні атрибути в Human і вони автоматично з'являться і в PythonDeveloper, і JSDeveloper. 
# Якщо потрібно розширити функціонал всіх розробників, то можна додати потрібні атрибути до класу Developer.
# І якщо треба додати особливу поведінку класу розробників конкретною мовою, 
# то можна додати або змінити атрибути класів PythonDeveloper або JSDeveloper.

# Таким чином у коді має бути лише одне місце, де визначено поведінку об'єкту. І якщо нам треба отримати інший об'єкт, 
# який має цю поведінку і якісь свої особливості, 
# ми можемо успадковуватись від класу з потрібними нам спільними атрибутами та додати унікальні.

# Цей підхід дозволяє писати менше коду та структурувати дані, 
# створюючи моделі реальних об'єктів з їх характеристиками (полями) та поведінкою (методами)


# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Cat, батьківським класом якого є клас Animal.
# У класі Cat виконайте перевизначення методу say, щоб він повертав рядок "Meow" для екземплярів класу Cat.

# Фактично ми виконуємо при цьому поліморфізм. 
# Поліморфізм - це здатність програми вибирати різні реалізації при виклику операцій з однією і тією ж назвою.
# Тобто при виклику методу say в екземпляра класу Cat викликається нова реалізація, а не успадкована від класу Animal

# Створіть також змінну cat, яка буде екземпляром класу Cat. 
# При створенні змінної cat ім'я кота має бути "Simon", а вага - 10 одиниць.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal: # Створення і реалізація батьківського класу . Опис дивись в 4 завдані.

#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         return "A-a-a"

#     def change_weight(self, weight):
#         self.weight = weight

# class Cat(Animal) : # Створення і реалізація підкласу *Cat батьківського класу *Animal .
#                     # Синтаксис  class *Імя_підкалсу(*Імя_батьківського класу).
#                     # підклас наслідує всі поля і методи бадьківського + може мати свої власні які доступні тільки йому.
#                     # поля і методи бадьківського можна  модифікувати для свого підкласу перевизначенням їх в реалізації підкласу.
#                     # Примітка : # Реалізація класу,чи підкласу - це код в тілі калсу/підкласу з всіма його зміними і методами якщо такі є.
#                                 # Підклас наслідує автоматично  всі поля і методи батьківського класу + може мати свої унікальні + 
#                                 # + може модифікувати атрибути батківського які будуть доступні тільки йому. 
    
#     def say(self):  # Модифікуємо(перевизначаємо) батьківський метод say(self).
#                     # При застосуванні методу *.say() до екзепляру підкласу *Cat - буде повртати завжди "Meow"
#                     # Приклад : екзепляр *cat = Cat("Simon", 10), *cat.say() поверне *Meow
#         # Примітка : для батьківських екзеплярів метод *.say() не зміниться при такій реалізації.
#                     # Приклад : *some_animal = Animal("Some_name","Some_wigt"), *some_animal.say() поверне *A-a-a
        
#         return "Meow" # Повернення визначеного значення *"Meow" з перевизначеного методу *.say() 
    
#     # def say(self, cat_say):  # Ще один приклад модифікації батьківський метод say(self) але вже з аргументом. *.say(*якесь_значення)
#     #                          # Така реалізація дозволяє міняти  значення яке поверне *.say(*якесь_значення) з методу для екзепляру класу *Cat
#     #     return cat_say       # Повернення з методу *.say(*якесь_значення) отримане зачення з *cat_say.

# cat = Cat("Simon", 10)         # Створення заданого умовою екземпляра класу *Cat

# # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# some_animal = Animal("Some_name","Some_wigt") # Створення тестового екземпляра батьківського класу *Animal (*для кращого розуміння матеріалу)

# print(f"\nПоля батьківського класу Animal для екзепляру some_animal :") # Принтимо шапку (для краси :) )
# print(f"*some_animal.nickname = {some_animal.nickname }, *some_animal.weight = {some_animal.weight} , *метод_some_animal.say() = {some_animal.say()}") # принтимо поля батьківського екземпляру (*для кращого розуміння матеріалу) 

# # Виведе:
# # Поля батьківського класу Animal для екзепляру some_animal :
# # *some_animal.nickname = Some_name, *some_animal.weight = Some_wigt , *метод_some_animal.say() = A-a-a

# cat = Cat("Murzyk", 25) # Створення тестового екземпляра батьківського класу *Animal (*для кращого розуміння матеріалу)

# cat.nickname = "Simon"  # Переписуємо(переназначаємо) значення поля *nickname для екземпляра *cat класу *Cat , 
#                         # методом класу *.nickname  батьківськго класу *Animal , 
#                         # Для нашого прикладу було *cat = Cat("Murzyk", 25) стане *cat = Cat("Simon", 25)

# cat.weight = 10         # Переписуємо(переназначаємо) значення поля *weight  для екземпляра *cat класу *Cat , 
#                         # методом класу *.weight   батьківськго класу *Animal , 
#                         # Для нашого прикладу було *cat = Cat("Simon", 25) стане *cat = Cat("Simon", 10)
#                         # Примітка : Значення поля *nickname == "Simon" бо ми його вже змінили раніше 
#                                     # цим переприсвоювання cat.nickname = "Simon"

# print(f"\nПоля підкласу *Cat класу *Animal для екзепляру cat :") # Принтимо шапку (для краси :) )
# print(f"*cat.nickname = {cat.nickname }, *cat.weight = {cat.weight} , *метод_cat.say() = {cat.say()}\n")  # принтимо поля екземпляру *cat  підкласу *Cat (*для кращого розуміння матеріалу)

# Виведе:
# Поля підкласу *Cat класу *Animal для екзепляру cat :
# *cat.nickname = Simon, *cat.weight = 10 , *метод_cat.say() = Meow

# ================================ Звдання 6 / Task 6  ======================================

# ================================  Method Resolution Order (MRO). ==========================

# Як бачимо, клас, що успадковує від іншого, автоматично отримує всі атрибути та методи першого класу. 
# У наших завданнях клас Cat отримує атрибути nickname та weight при ініціалізації екземпляра від класу Animal. 
# Початковий клас Animal називається батьком, а новий клас Cat - нащадком.
# Клас Cat успадковує атрибути та методи батька, але при цьому також може визначати власні атрибути та методи.

# class Animal:
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight


# class Cat(Animal):
#     def say(self):
#         return "Meow"


# cat = Cat("Simon", 10)
# Але що буде якщо нам необхідно для класу Cat ввести нову властивість при створенні екземпляра, 
# як порода breed? І виклик екземпляра класу Cat має виглядати так:

# cat = Cat("Simon", 10, 'british')
# Для цього наш код має прийняти такий вигляд:

# class Animal:
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight


# class Cat(Animal):
#     def __init__(self, nickname, weight, breed):
#         super().__init__(nickname, weight)
#         self.breed = breed
        
#     def say(self):
#         return "Meow"


# cat = Cat("Simon", 10, "british")
# print(cat.nickname)  # Simon
# print(cat.breed)  # british
# print(cat.weight)  # 10
# Метод __init__() отримує всю інформацію, що необхідна для створення екземпляра Cat. 
# Функція super() спеціальна функція, яка допомагає Python пов'язати нащадка з батьком. 
# Ця функція вказує Python явно викликати метод __init__() класу Animal, що є батьком Cat, 
# внаслідок чого екземпляр Cat отримує всі атрибути класу батька. 
# Ім'я super відповідає поширеній термінології: клас батько називається суперкласом, а клас нащадок - субкласом. Значить, 
# Animal - це суперклас, а Cat - субклас.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Dog, батьківським класом якого є клас Animal. 
# У класі Dog виконайте перевизначення методу say, щоб він повертав рядок "Woof" для екземплярів класу Dog.

# У конструкторі класу Dog введіть нову властивість breed - порода, 
# при цьому повинні залишитись всі властивості, успадковані від класу Animal.

# Створіть у коді наступний екземпляр класу Dog.

# dog = Dog("Barbos", 23, "labrador")

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal: # Створення і реалізація батьківського класу (*суперклас) . Опис дивись в 4 завдані.

#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight


# class Dog(Animal): #  # Створення і реалізація підкласу(*субклас) *Dog , батьківського класу(*суперклас) *Animal .
# #                     # Синтаксис  class *Імя_підкалсу(*Імя_батьківського класу).
# #                     # підклас наслідує всі поля і методи бадьківського + може мати свої власні які доступні тільки йому.
# #                     # поля і методи бадьківського можна  модифікувати для свого підкласу перевизначенням їх в реалізації підкласу.
# #                     # Примітка : # Реалізація класу,чи підкласу - це код в тілі калсу/підкласу з всіма його зміними і методами якщо такі є.
# #                                 # Підклас наслідує автоматично  всі поля і методи батьківського класу + може мати свої унікальні + 
# #                                 # + може модифікувати атрибути батківського які будуть доступні тільки йому.
#                                   # Батьківський клас, суперклас,коріневий, головний, тощо... - просто різні назви одного і того самого -
#                                   # - це клас який в описі немає круглих дужок # class Animal: - (батьківський)
#                                   # підклас, субкалас, нащадок,тощо... - клас який при оголошені має круглі дужки і в душках вказано батьківський клас 
#                                   # атрибути якого він наслідує  # class Dog(Animal): - (нащадок *Animal)
                                  

#      def __init__(self, nickname, weight, breed):  # Оголошення власного конструктора підкласу *Dog(Animal). 
#                                                    # Потрібний якщо ми хочемо щоб наш підклас мав свої обовязкові унікальні поля.
#                             # В нашому конструкторі підкласу *Dog(Animal)
#                             # ми перших два обовязкових поля передамо явно з батьківського класу *Anamal за допомогою спеціальної функції *super()
#                             # а третє - (обовязкове поле для екзеплярів підкласу *Dog, яке хочемо створити) *breed - створюємо класично # *self.breed = breed
                                                  
#         super().__init__(nickname, weight) # Такий запис - це явна передача батьківських полів *Animal, конструктору підкласу *Dog(Animal) 
#                                            # де *super() - спеціальна вбудована Python функція для цих цілей, 
#                                            # а *.__init__(nickname, weight) - це спеціальний синтаксис батьківського конструкора 
#                                            # Спочатку йде крапочка "." , далі імя коструктора __init__ , 
#                                            # *(nickname, weight) далі в круглих дужках перелік полів які хочемо передати явно коструктору підкласу. 
#                                            # Зверніть увагу ,що в спеціальному синктасі ,відсутний обовязковий аргумент *self  
       
#         self.breed = breed                 # Класичне оголошення обовязкового поля кострукора, *self.breed = breed 

#      def say(self):                  # перевизначення батьківського методу *.say()  з класу *Anamal 
#         return "Woof"                # При виклкику матоду *.say() для екземплярів підкласу *Dog , буде повертати завжди *"Woof"


# dog = Dog("Barbos", 23, "labrador")  # Створення екзепляру підкласу *Dog з наперед визачиними полями. 
#                                      # Тепер всі екзепляри *Dog мусять містити 3 обовязових поля.
#                                      # Дав перші обовязкові поля , такі ж як і в Батьківському класі *Animal, Доступ до них методами бітківського класу *.nicname і *.weght
#                                      # а третє обовязове(тільки для екзеплярів *Dog) *breed . Доступ до його значення  методом *.breed

 # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# dog_shablon = Dog("Barbos", 23, "labrador") # Створення екземпляру *dog_shablon підкласу *Dog з наперед заданми полями.

# dog = Dog(dog_shablon.nickname, dog_shablon.weight, dog_shablon.breed) # Створення екземпляру *dog підкласу *Dog з наперед не заданими  полями.
#                                                                        # В нашому випадку буде наслідувати дані з екзепляру *dog_shablon 

# print(dog.nickname, dog.weight, dog.breed) # Принтемо результа . # Barbos 23 labrador

# ================================ Звдання 7 / Task 7  ======================================

# ================================   Успадкування .Наслідування.Method Resolution Order (MRO).  ==========================

# При моделюванні явищ реального світу класи з часом доповнюються дедалі більшою кількістю подробиць. 
# Списки атрибутів і методів збільшуються, і через деякий час класи стають довгими та важко підтримуються в розробці.
# У такій ситуації частину одного класу можна виділити у вигляді окремого класу. 
# Код великого класу розбивається на менші класи, що працюють у взаємодії один з одним.

# Наприклад, при подальшому доопрацюванні класу Cat може виявитися, 
# що в ньому стало занадто багато атрибутів та методів, які стосуються господаря кота. 
# У такому разі все, що відноситься до власника кота, можна перемістити в окремий клас ім'ям Owner. 
# Потім екземпляр Owner стає атрибутом класу Cat:

# class Animal:
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight


# class Owner:
#     def __init__(self, name, age, address):
#         self.name = name
#         self.age = age
#         self.address = address


# class Cat(Animal):
#     def __init__(self, nickname, weight, breed, owner):
#         self.breed = breed
#         self.owner = owner
#         super().__init__(nickname, weight)

#     def say(self):
#         return "Meow"


# owner = Owner("Sherlock", 24, "London, 221B Baker Street")
# cat = Cat("Simon", 10, "british", owner)
# Може здатися, що такий варіант потребує більше додаткової роботи,
# але тепер господаря кота (клас Owner) можна моделювати з будь-яким ступенем деталізації, без втручання у клас Cat.



# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для минулого завдання додамо клас Owner — власника собаки. У класу є три атрибути: ім'я — name, вік — age та адреса — address. 
# Також необхідно реалізувати метод info, який повертає словник з ключами 'name', 'age' і 'address', 
# та значення яких дорівнюють відповідним властивостям екземпляра класу.

# Реалізувати для класу Dog атрибут owner, який буде екземпляром класу Owner. 
# Додати до класу Dog метод who_is_owner, який повертає результат виклику методу info екземпляра класу Owner, 
# тобто це словник з ключами name, age та address власника.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


# class Animal: # Створення і реалізація батьківського класу (*суперклас) *Animal. Опис дивись в 4 завдані.
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight


# class Owner:   # Створення і реалізація батьківського класу (*суперклас) *Owner.
#     '''Батьківський клас *Owner , екзепляри класу мають містити три обовязкові поля: *name, *age, *address 
#      Також реалізовано метод *.info() який повертає словник з ключами *"name", *"age", *"address" і значеннями відповідних полів екземплярів цього класу
#     Приклад: *vlasnyk = Owner("Ander", 25 , "Lviv. vul.Franka 56") - заданий екзепляр *vlasnyk клас *Owner
#              *vlasnyk.info() - повертає *{'name': 'Ander', 'age': 25, 'address': 'Lviv. vul.Franka 56'} - результат застосування методу *.info() до екзепляра *vlasnyk клас *Owner'''

#     def __init__(self, name, age, address): # Конструктор суперкласу *Owner, Містить 3 обовязкові поля *name, *age, *address. Реалізація класична .
        
#         self.name = name # оголошення поля *name .Класична.
#         self.age = age   # оголошення поля *age .Класична.
#         self.address = address ## оголошення поля *address .Класична.

    
#     def info(self): # *.info() - метод класу *Owner. Без параметрів (якщо аргументом методу є тільки спеціальна зміна класу *self - то цей метод не приймає жодних аргументів. )
        
        
       
#        owner_dict = {"name":self.name, "age":self.age, "address": self.address} # *owner_dict , буде містити шаблон словника який повертаємо з функції .
#                                                                                 # Шаблон : {key_1 : self.імя_першого_поля_екзепляру_class_Owner, key_2 : self.імя_другого_поля_екзепляру_class_Owner, ...}
#                                                                                         # і так скільки потрібно ключів але ,можливо ,не більше ніж є полів в класі.  
#                             # Для нашого прикладу :визначені ключі "name" , "age", "address" будуть містити відповідні значенння  з конкретного екзкмпляра калусу *Owner
#                           #Приклад: *vlasnyk = Owner("Ander", 25 , "Lviv. vul.Franka 56") - заданий екзепляр *vlasnyk клас *Owner
#                                     #*vlasnyk.info() - повертає *{'name': 'Ander', 'age': 25, 'address': 'Lviv. vul.Franka 56'} - результат застосування методу *.info() до екзепляра *vlasnyk клас *Owner. 
       
#        return owner_dict # Повертаємо словник з методу.
   
# class Dog(Animal):
#     ''' Субклас *Dog суперкласу *Animal 
#      Має свій конструктор *__init__() де перші два обовязкові поля наслідуються з класу *Animal(через спеціальну функцію *super()), а наступні два  *breed, *owner власні.
#      Також *Dog має два власних  методи які працюють для його екзеплярів : метод *.say() - який повертає "Woof"  
#                                                                            метод *.who_is_owner() - повертає метод *.info(self) екзепляру *Owner, 
#                                                                                 Тому  поле *owner класу *Dog , має містити екзепляр класу *Owner або зміну яка на нього посилається.
#                                                                                 інакше виклики цього методу ,буде повертати полику *AttributeError: 'str' object has no attribute 'info' '''
    
#     def __init__(self, nickname, weight, breed, owner ): # Власний конструктор субкласу *Dog , містить реалізацію 4 обовязкових полів цього субкласу .
        
#         self.breed = breed # оголошення(реалізація) поля *breed .Класична.
#         self.owner = owner # оголошення(реалізація) поля *owner .Класична.
        
#         super().__init__(nickname, weight) # оголошення(реалізація) полів *nickname, *weight через посилання на батьківсьий клас *Animal.
#                                            # Такий запис - це явна передача батьківських полів *Animal, конструктору підкласу *Dog(Animal) 
# #                                            # де *super() - спеціальна вбудована Python функція для цих цілей, 
# #                                            # а *.__init__(nickname, weight) - це спеціальний синтаксис батьківського конструкора 
# #                                            # Спочатку йде крапочка "." , далі імя коструктора __init__ , 
# #                                            # *(nickname, weight) далі в круглих дужках перелік полів які хочемо передати явно коструктору підкласу. 
# #                                            # Зверніть увагу ,що в спеціальному синктасі ,відсутний обовязковий аргумент *self  

#     def say(self):   #  метод *.say() - який повертає "Woof" 
#         return "Woof" # повернення "Woof"

#     def who_is_owner(self):  # метод *.who_is_owner() - повертає метод *.info(self) екзепляру *Owner, 
#                                      # Тому  поле *owner класу *Dog , має містити екзепляр класу *Owner або зміну яка на нього посилається.
#                                      # інакше виклики цього методу ,буде повертати полику *AttributeError: 'str' object has no attribute 'info' '''
#         info_owner_dog = self.owner.info() # зміній *info_owner_dog присвоюємо посилання *self.owner.info()
#                                            # де *self(спец_зміна класу, яка вказує інтерпритатору Python шукати в коді поле те що буде вказано відразу після крапки, як відувається пошук читай *ethod Resolution Order (MRO).  )
#                                            # *.owner - це значення , що міститься в відповідному полі нашого субкласу *Dog . 
#                                            # *.info() - це метод класу *Owner .
#         # Примітка : Оскільки метод *.who_is_owner() - реалізований, як посилання на метод *.info() класу *Owner, то  поле *owner субкласу *Dog , 
#                     # має містити екзепляр класу *Owner або змінну яка на нього вказує(посилається/містить) . інакше буде видавати помилки при спробі застосувати цкй метод.
        
#         return info_owner_dog # Повертає значення що містить *info_owner_dog

#  # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +++
    
# vlasnyk = Owner("Ander", 25 , "Lviv. vul.Franka 56") # Тестовий екзепляр класу *Owner з наперед заданими значеннями відповідних обовязкових полів(конкретний екзепляр класу)

# dog = Dog("Simon", 10, "british", vlasnyk) # Тестовий екзепляр класу *Dog з наперед заданими значеннями перших 3 обовязкових полів ,
#                                                     # четверте обовязкове поле - містить зміну *vlasnyk - яка вказує на заданий вище екзепляр класу *Owner  . 

# print(vlasnyk.name, vlasnyk.age, vlasnyk.address)      # Тестовий принт #  Ander 25 Lviv. vul.Franka 56

# print(vlasnyk.info())                                  # Тестовий принт # {'name': 'Ander', 'age': 25, 'address': 'Lviv. vul.Franka 56'}

# print(dog.nickname , dog.weight, dog.breed, dog.owner) # Тестовий принт # Simon 10 british <__main__.Owner object at 0x00000194174CB8F0>

# print(dog.who_is_owner())                              # Тестовий принт # {'name': 'Ander', 'age': 25, 'address': 'Lviv. vul.Franka 56'}


# ================================ Звдання 8 / Task 8  ======================================

# ================================   Успадкування .Наслідування. Method Resolution Order (MRO). =========================================================

# Успадкування — це дуже потужний інструмент. Наслідувати можна не тільки від одного класу, 
# а можна одразу від кількох. Таким чином можна отримувати об'єкти, що поєднують у собі властивості багатьох класів. 
# Тут має виникнути питання, а що буде, якщо кілька класів мають атрибути з однаковим ім'ям?

# Для відповіді на це питання треба зрозуміти, як Python шукає атрибути (поля або методи) в об'єктах. 
# Власне, це є MRO (Method Resolution Order). MRO у Python працює наступним чином:

# Шукає атрибут серед атрибутів самого класу. Саме завдяки цьому, ви можете "перевизначати" батьківські атрибути.
# Шукає атрибут у першого з батьків (той, що вказано першим у списку батьків).
# Шукає атрибут у наступного батька у списку батьків, доки такі є.
# Шукає атрибут у батьках першого батька.
# Повторює п.4 для всіх батьків.
# Викликає виключення, що атрибут не знайдено.
# Пошуки закінчуються, як тільки атрибут знайдено.

# class A:
#     x = 'I am A class'


# class B:
#     x = 'I am B class'
#     y = 'I exist only in B'


# class C(A, B):
#     z = "This exists only in C"


# c = C()
# print(c.z)  # This exists only in C
# print(c.y)  # I exist only in B
# print(c.x)  # I am A class
# З цього прикладу видно, що у класі C поле x береться з A класу. Якщо ж в цьому ж прикладі змінити список батьків, 
# то отримаємо:

# class A:
#     x = 'I am A class'


# class B:
#     x = 'I am B class'
#     y = 'I exist only in B'


# class C(B, A):
#     z = "This exists only in C"


# c = C()
# print(c.z)  # This exists only in C
# print(c.y)  # I exist only in B
# print(c.x)  # I am B class
# Тепер у класі C поле x береться з B класу.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть два класи: CatDog та DogCat. Ці класи повинні наслідуватись від двох класів відразу: Cat та Dog. 
# Після успадкування в екземпляра класу CatDog, батьківський метод say повинен повертати "Meow", а у класу DogCat — "Woof". 
# Для обох зазначених класів реалізуйте метод info, 
# який повертає рядок у наступному форматі f"{self.nickname}-{self.weight}".

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal: # Створення і реалізація батьківського класу (*суперклас) *Animal. 
#     ''' Клас містить два обовязкові поля : *nickname, *weight та та один путий метод *.say() '''
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self): # реалізація пустого метода *.say() (він пустий бо в тілі тільки опертор *pass ). 
#         pass


# class Cat(Animal): # Створення і реалізація класу *Cat що є субкласом для класу *Animal
#     ''' Субклас *Cat ,в дані реалізації не містить жодних своїх полів , (всі поля і методи, наслідує  від батьківського класу)
#      Має один свій метод *.say() який при зверненні до екзепляра *Cat повертає *"Meow"  '''
    
#     def say(self): # Реалізація власного метода *.say() , який при зверненні до екзепляра *Cat повертає *"Meow"  
#         return "Meow"


# class Dog(Animal): # Створення і реалізація класу *Dog що є субкласом для класу *Animal
#     ''' Субклас *Dog ,в дані реалізації, не містить жодних своїх полів  (всі поля і методи, наслідує  від батьківського класу)
#      Має один свій метод *.say() який при зверненні до екзепляра *Dog повертає *"Woof"  '''
    
#     def say(self):  # Реалізація власного метода *.say() , який при зверненні до екзепляра *Dog повертає *"Woof" 
#         return "Woof"
    
# class CatDog(Cat, Dog): # Створення і реалізація класу *CatDog,  що є субкласом для відразу двох класів ,
#                         #  *Cat і *Dog що в свою чергу є субкласами супер класу *Animal
#     '''Субклас *CatDog ,в дані реалізації , не містить жодних своїх полів.
#       Всі атрибути(поля і методи) успадковує від класів *Cat і Dog , але містить два своїх методи :
#       метод *.say() 
#       метод *.info()   '''
#     #Примітка : При даній реалізації класів, поля буде наслідувати, по факту, з *Animal .Читай Method Resolution Order (MRO)

#     def say(self): # Реалізація власного метода *.say() ( в нашому випадку реалізація відбувається через спеціальну функцію класів *super())
        
#         catdog_say = super().say() # *super().say() - такий запис говорить що шукай відразу (те що після крапки) в класі який є батьківський до даного.
#                                    # В нашому випадку це посилання на метод *.say() в класі який є батькіським для нашого. 
#                                    # Поверне перше знайдене співпадіння. Пошук відбудиться за принципом Method Resolution Order (MRO).
#                                    # В нашому випадку , *CatDog має два батьківські класи , Перший *Cat і другий *Dog ,
#                                    # Оскільки клас *Cat має свою реалізацію методу *.say() яка поертає "Meow" то його і поверне.
#         # Примітка: спеціальна функція класів *super(). 
#                     # шукає в класах те що після крапочки , Спочатку в класі *Cat(оскільки він перший в даній реалізації),
#                     # якщо не найде в першому , шукає в наступному *Dog(оскільки він другий в даній реалізації) і так дальше за порядком .
#                     # Завжди повертає те що знайде перше . 
#                     # Якщо спеціальна змінна класів *self. - шукає поля (зміні) (ті що після крапочки) і повертає перше знайдене , де пошук завжди відбувається спочатку в самому класі .
#                     # То спеціальна функція класів *super(). - шукає методи відразу в батьківському для даного класі, і пошук починає в першому батьківському класі,
#                     # якщо не находить , шукє в наступному за порядком батьківському класі. Якщо ніде не знайде поверне помилку. 
                           
#         return catdog_say # Повертаємо значення що буде містит *catdog_say 
    
#     def info(self):  # Реалізація власного метода *.info()  .Класична.

#         return f"{self.nickname}-{self.weight}" # Повертає стрічку заданого формату , де реалізацію полів *self.nickname і self.weight візьме, по факту , з суперкласу *Animal при даній ралізації наших класів.
#                                                 # Приклад: екзепляр *catdog = CatDog("Simon", 10), 
#                                                                   # *catdog.info() поерне - Simon-10 
    
# class DogCat(Dog, Cat):# Створення і реалізація класу *CatDog,  що є субкласом для відразу двох класів ,
#                         #  *Dog і *Cat що в свою чергу є субкласами супер класу *Animal, 
#                         # Порядок класів (те в якій послідовності вони перечислятються в круглих дужках) має значення , читай *MRO(Method Resolution Order)
#     '''Субклас *DogCat , в дані реалізації , не містить жодних своїх полів.
#       Всі атрибути(поля і методи) успадковує від класів *Dog і *Cat , але містить два своїх методи :
#       метод *.say() 
#       метод *.info()   '''

#     def say(self): # Реалізація власного метода *.say() (в нашому випадку реалізація відбувається через спеціальну функцію класів *super())
#                    # Опис читай в аналогічному методі  реалізованому в  класу *CatDog(Cat, Dog) (трішки вище в коді цього завдання)
#         dogcat_say = super().say() 

#         return dogcat_say  # # Повертаємо значення що буде містит *dogcat_say  
    
#     def info(self):   # Реалізація власного метода *.info()  .Класична.

#         return f"{self.nickname}-{self.weight}" # Приклад: екзепляр *dogcat = DogCat("Bars", 30), 
#                                                                   # *dogcat.info() поверне - Bars-30


# #  # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +++
    
# catdog = CatDog("Cat_Simon", 15) # Тестовий екзепляр класу *CatDog з наперед заданими значеннями відповідних обовязкових полів(конкретний екзепляр класу)
#                              # При даній реалізації наших класів в цьому завдані , містить два обовязкових поля *nickname і *weight успадкованих від батьківського класу *Anmal
#                              # Відповідно звертаємось до полів класу екзепляру *CatDog, методами класу *Anamal. 
#                              # *catdog.nickname поверне - Cat_Simon а *catdog.weight поверне - 15

# print(catdog.nickname , catdog.weight) # тестовий принт #  Cat_Simon 15
# print(catdog.say())                    # тестовий принт #  Meow
# print(catdog.info())                   # тестовий принт #  Cat_Simon-15

# dogcat = DogCat("Dog_Bars", 30) # Тестовий екзепляр класу *DogCat з наперед заданими значеннями відповідних обовязкових полів(конкретний екзепляр класу)
#                             # При даній реалізації наших класів в цьому завдані , містить два обовязкових поля *nickname і *weight успадкованих від батьківського класу *Anmal
#                             # Відповідно звертаємось до полів класу екзепляру *CatDog, методами класу *Anamal. 
#                             # *dogcat.nickname поверне - Dog_Bars, а *dogcat.weight поверне - 30
# print(dogcat.nickname , dogcat.weight) # тестовий принт #  Dog_Bars 30
# print(dogcat.say())                    # тестовий принт #  Woof
# print(dogcat.info())                   # тестовий принт #  Dog_Bars-30


# ================================ Звдання 9 / Task 9  ======================================

# ================================   Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString) ============================

#                                      **UserDict**

# Часто для роботи потрібно створити об'єкти, які поводяться як стандартні контейнери Python, 
# але з модифікованою поведінкою. Ви, звичайно, можете спробувати успадкувати dict, str, list, 
# але це може призвести до ряду непередбачених помилок. 
# Правильний спосіб отримати модифікований контейнер — 
# - це використовувати пакет collections та класи UserList, UserDict, UserString, які в ньому є.

# Всі ці класи поводяться точно як вбудовані контейнери з тією лише відмінністю, 
# що самі дані лежать у полі data у цих класів і ви можете використовувати це поле на свій розсуд.

# from collections import UserDict


# class ValueSearchableDict(UserDict):
#     def has_in_values(self, value):
#         return value in self.data.values()


# as_dict = ValueSearchableDict()
# as_dict['a'] = 1
# as_dict.has_in_values(1)  # True
# as_dict.has_in_values(2)  # False
# У цьому прикладі ми створили клас, який поводиться як словник, але в ньому є додатковий метод, 
# який перевіряє наявність деякого value серед значень у цьому словнику.

# from collections import UserList


# class CountableList(UserList):
#     def sum(self):
#         return sum(map(lambda x: int(x), self.data))


# countable = CountableList([1, '2', 3, '4'])
# countable.append('5')
# countable.sum()  # 15
# У цьому прикладі ми створили клас, який поводиться як список, але в ньому є метод sum ,
# який повертає суму всього вмісту цього класу, при цьому перетворюючи рядки на цілі числа.

# from collections import UserString


# class TruncatedString(UserString):
#     MAX_LEN = 7

#     def truncate(self):
#         self.data = self.data[:self.MAX_LEN]


# ts = TruncatedString('abcdefghjklmnop')
# ts.truncate()
# print(ts)  # abcdefg
# Останній приклад показує модифікований рядок з методом truncate, який обмежує розмір рядка до MAX_LEN символів.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У четвертому модулі ми реалізували функцію lookup_key для пошуку всіх ключів за значенням у словнику. 
# Першим параметром у функцію ми передавали словник, а другим – значення, яке хотіли знайти. 
# Результатом був список ключів або порожній список, якщо ми нічого не знаходили.

# def lookup_key(data, value):
#     keys = []
#     for key in data:
#         if data[key] == value:
#             keys.append(key)
#     return keys
# Створіть клас LookUpKeyDict, батьком якого буде клас UserDict. 
# Зробіть функцію lookup_key методом класу LookUpKeyDict.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from collections import UserDict # З бібліотеки *collections імпортуємо вбудований клас *UserDict(клас словників)  - 
#                                  # - це клас в якому реалізовано всі методи словників(*.update(),*.get() ...тощо) 
#     # Осільки субкласи наслідують всі методи від батькіського , але в них можна перевизначати усподковані батьківські методи під конкретні свої потреби,
#     # то це значно розширяє можливості роботи з кодом а також розуміння для інших що відбувається . 
#     # Щоб зрозуміти звідки взявся такий результат, достатньо глянути якому класу/підкласу належить екземпляр і який метод був застосований ,
#     # глянувши реалізацію цього методу в цьому класі(чи в батьківскому, якщо субклас немає власної реалізації цього методу)
#     # Примітка : Всі вбудовані типи даних і стандартіні методи - реалізовані в Python через класи(обєкти) . 
#               # Просто ви не можете нічого в них змінти. Це реалізовано щоб всі могли виконувати код запевним стандартом і бачити один і той самий резульат.
#               # Інакше кажучи : *some_dict_original = {}  і *some_dict_UserDict = UserDict() це одне і те саме .
#               # Тобто для *some_dict_original і для *some_dict_UserDict будуть діяти всі методи які є вбудовані в пайтон строго з описомом 
#               # Одна відміність що самі дані лежать у полі *data цього класу і у вас є доступ до цього поля , ви можете використовувати це поле на свій розсуд.
#               # Звернення до поля *data відбувається класично для класів *self.data
#         # Примітка : краще не використовувати зміну *data для якихось інших цілей, щоб не виникало проблем зочікуваним результатом.
#               # Якщо створити субкалас для якого батьківським буде *UserDict з бібліотеки *collections(можна створити і свій клас просто *UserDict один в один має реалізовані всі станадртні методи словника) , 
#               # то можна всі стандартні методи переназначити або ж тільки частину і з них.
#               # Якщо вам потрібно розширити функціонал стандартних методів, найзручніше , в більшості випадків , створити клас/субклас, і написати свою реалізацію стандартних методів в цьому класі/субкласі, чи добавити нові , на ваш розсуд.
#               # Всі ці додаткові чи зміненні стандартні методи будуть робочими тільки для екзеплярів вашого субкласу/класу у вашому коді.

# class LookUpKeyDict(UserDict):  # Створення і реалізація класу *LookUpKeyDict що є субкласом для класу *UserDict з бібілотеки *collections
#     ''' Субклас *LookUpKeyDict в дані реалізації, немає своїх полів , успадковує всі поля і методи від батьківського *UserDict 
#         Має один свій власний метод *.lookup_key(*arg) - який приймає один аргумент (якесь значення ) 
#         і якщо таке значення міститься в словнику з поля *data повертає список клучів з слованика в яких є це значення.
#         Якщо не знаходить значення , повертає пустий список. 
#     Примітка : *UserDict це вбудований клас словника з бібіліотеки *collections , 
#                який містить одне поле *data(всі дані з конкретного екзепляра бубуть містяться тут) 
#                 і всіх стандартних методів словників(*.get(), *.update(), *.pop() та інших ...)  '''
    
#     def lookup_key(self, value): # Реалізація власного методу *.lookup_key(*arg) для екзеплярів *LookUpKeyDict
#         ''' Метод(функція) приймає один аргумент, тип даних довільний 
#          Перевіряє чи є він серед значень словника *data , Якщо є , то повертає список ключів які містять це значення, інакше повертає пустий список '''
        
#         keys = [] # список який будемо повертати з методу. Початкове значення пустий .
        
#         for key in self.data: # Цикл в якому будемо проходитись по ключах(*key) з словнику *data # *self.data - це звернення до батьківського поля яке буде містити наш словник з екзепляру субкласу *LookUpKeyDict )
#                               # І за поточним ключем повертати значення і перевіряти чи воно рівне значенню *value. 
#                               # Якщо рівне, добавляємо його в наш список *keys , якщо ні то берем наступний ключ.і так поки незакінчаться ключі в словнику *data
#                               # По завершенню циклу, з методу,  повертаэмо значення сформованого списку *keys
            
#             if self.data[key] == value: # Умова, якщо значення поточного ключа *key з словника *data,
#                                         #  дорівнює значеню, що міститься у *value
             
#              keys.append(key)           # Якщо умова виконалась, з начить поточний ключ *key містить задане значення *value
#                                         # Вбудованим методом *.append(*якийсь_ключ) добавляємо його в наш список *keys
#         return keys # Повертаємо сформваний список з методу.


#  #  # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +++

# some_dict = LookUpKeyDict() # Тестовий екзепляр класу *LookUpKeyDict , який по замовчуванню буде себе поводити як пустий словник
#                             # Єдина відміність ,при даній реалізації класу *LookUpKeyDict , 
#                             # що крім всіх стандартних методів словника, до нього можна застосувати власний метод субкласу 
#                             #  *.lookup_key(*args)

# # Наповнюємо *some_dict - наш екзепляр(словник) субкласу *LookUpKeyDict - значеннями,
# # щоб переконатись що він поводить себе як звичайний словники,
# # але для нього буде працювати ще й власний метод класу *.lookup_key(*якесь_значення)

# some_dict["key1"] = 20  # ключу "key1" присвоємо значення 20. 
#                         # Оскільки *some_dict початково пустий то створить першу пару словника
#                         # *some_dict = {"key1":20}
# some_dict["key2"] = 25  # ключу "key2" присвоємо значення 25. 
#                         # Оскільки *some_dict поки немає ключа "key2", то створить другу пару словника 
#                         # *some_dict = {"key1":20, "key2":25}
# some_dict["key3"] = 20  # Аналогічно до попередніх двох створюємо наступну пару словника 
#                         # *some_dict = {"key1":20, "key2":25, "key3":20 }

# some_dict.update({"key5":20, "key6":25 }) # Застосовуємо стандартний методи словників *.update(*dict)
#                                           # і він також працює стандартно як і дя всіх словників .
#                                           # *some_dict = {'key1': 20, 'key2': 25, 'key3': 20, 'key5': 20, 'key6': 25}
# print(some_dict.get("key6")) # Принтить 25 (начення ключка "key6" з екзепляра *some_dict)

# # З  прикладів вище , ми переконались що наш екзепляр *some_dict працює аналогічно будьякому іншому словнику, 
# # про те він підтримує і наш власний метод *.lookup_key(*arg) якого не має в жодному іншому словнику. 
# #  Примітка : що робить власний  метод *.lookup_key(*arg) класу *LookUpKeyDict дивись в реалізації цього методу в даному класі в коді вище
#               # в частині що містить опис і реалізацію класу *LookUpKeyDict(UserDict) .

# print(some_dict.lookup_key(20)) # Принтемо результ виконня методу з заданим аргументом 20 .
#                                 # Оскільки 3 ключі мають значення 20 в нашому словнику то виведе:
#                                 #  *['key1', 'key3', 'key5']
                                  
# print(some_dict.lookup_key(25))  # Принтемо результ виконня методу з заданим аргументом 25 .
#                                  # Оскільки 2 ключі мають значення 25 в нашому словнику то виведе:
#                                  # *['key2', 'key6']


# ================================ Звдання 10 / Task 10  ======================================

# ================================   Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString) =======
                                            
#                                      **UserList**

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++
# Перепишемо завдання розрахунку заборгованостей з комунальних послуг за допомогою класу UserList.

# payment = [1, -3, 4]


# def amount_payment(payment):
#     sum = 0
#     for value in payment:
#         if value > 0:
#             sum = sum + value
#     return sum
# Нагадаємо умову. У нас є список показань заборгованостей з комунальних послуг наприкінці місяця, список payment. 
# Заборгованості можуть бути від'ємними — у нас переплата, або додатними, якщо потрібно сплатити за рахунками.
# Створіть клас AmountPaymentList, успадковуйте його від класу UserList. 
# Зробіть функцію amount_payment методом класу AmountPaymentList.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Це завдання за суттю схоже на 9 . Тільки замість  вбудованого класу *UserDict(клас словників),
            # ми використаємо вбудований клас *UserList-(клас списків) . І попрактикуємося з ними. 
            # Самі механізми робти з *UserList будуть аналогічні *UserDict. Дивись детальніший опис чому так в 9 завданні.

# from collections import UserList # З бібліотеки *collections імпортуємо вбудований клас *UserList - 
#                                  # - це клас в якому реалізовано всі методи списків(*.append(),*.count(),remjve() ...тощо)
#                                  # Поле *data - буде містити переданий список, *self.data - посилання на ці дані для субкасів.


# class AmountPaymentList(UserList): # Створення і реалізація класу *AmountPaymentList що є субкласом для класу *UserList(клас списків) з бібілотеки *collections
#     ''' Субклас *AmountPaymentList, в дані реалізації, немає своїх полів , успадковує всі поля і методи від батьківського *UserList(клас списків)  
#          Має один свій власний метод *amount_payment() - без аргументів. 
#           повертає суму всіх додатніх чисел з переданого списку (сума заборгованості, оскільки за умовою відємні числа в списку це перелата)  '''
    
#     def amount_payment(self): # Реалізація власного методу *.amount_payment() для екзеплярів *AmountPaymentList
#         ''' Метод(функція) без аргументів, сумує всі додатні числа з переданого в *data списку і повертає результат.
#          Якщо список порожній або ж всі не містить додатніх чисел поветає 0. '''
        
#         sum = 0    # зміна в яку будемо додавати всі наші додатні числа з переданого списку . Початкове значення 0
#         for value in self.data: # Цикл в якому будемо проходитись по елементах списку *data 
#                                 # *self.data - це звернення до батьківського поля яке буде містити наш список екзепляру субкласу *AmountPaymentList 
            
#             if value > 0:           # Умова в якій перевіряємо чи поточний елемент списку додатній (більший 0)
#                 sum = sum + value   # Якщо умова виконалась, значить елемент додатній , додаємо його до суми , 
#                                     # В кінці цику *sum буде містити суму всіх додатніх чисел з передаyого списку.
#         return sum                  # Повертаємо значення суми з методу(функції)


# # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +++

# payment_list = AmountPaymentList()  # Тестовий екзепляр класу *AmountPaymentList, який по замовчуванню буде себе поводити як пустий список
#                                 # Єдина відміність ,при даній реалізації класу *AmountPaymentList, 
#                                 # що крім всіх стандартних методів списку, до нього можна застосувати власний метод субкласу *.amount_payment()
# # Наповнюємо *payment_list - наш екзепляр(список) субкласу *AmountPaymentList - значеннями,
# # щоб переконатись що він поводить себе як звичайний список,
# # але для нього буде працювати ще й власний метод класу *.amount_payment()

# payment = [1, -3, 4]  # Звичайний список . #  *[1, -3, 4]
# payment_list = AmountPaymentList(payment)   # Можна відразу передати звичайний список в наш екзкпляр. 
# print(payment_list)  # Принтимо результа    #  *[1, -3, 4]

# payment_list.append(5) # Добавимо в наш екзепляр ще один елемент .Для того скористаємось стандартим меодом списків *.append(*якесь_значення)
# print(payment_list)    # Перевіряємо результат . # *[1, -3, 4, 5]

# print(payment_list[0]) # Принтимо перший елмент списку, індекс 0  #  *1
# payment_list = payment_list + payment # Присвоюємо нашому екзепляру *payment_list  обєднання двох списків , 
#                                       # До з нашого екзепляру дадаємо звичайний список *payment 
# print(payment_list) # Принтимо результат обєдная списків . #  *[1, -3, 4, 5, 1, -3, 4]

# # З  прикладів вище , ми переконались що наш екзепляр *payment_list працює аналогічно будь якому іншому списку , 
# # про те він підтримує і наш власний метод *.amount_payment() якого не має в жодному іншому списку. 
# # #  Примітка : що робить власний  метод *.amount_payment() класу *AmountPaymentList дивись в реалізації цього методу в даному класі в коді вище
# #               # в частині що містить опис і реалізацію класу *AmountPaymentList(UserList) .
# print(payment_list.amount_payment()) # Принтимо результат методу *.amount_payment() для нашого екзепляра *payment_list
#                                      # Вииведе  *15, 
#                         # Якщо додати всі доданні елементи з нашого списку *[1, -3, 4, 5, 1, -3, 4] то вийде також *15 . 


# ================================ Звдання 11 / Task 11  ======================================

# ================================   Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString) =======
                                            
#                                      **UserString**

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас NumberString, успадкуйте його від класу UserString, визначте для нього метод number_count(self), 
# який буде рахувати кількість цифр у рядку.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : Це завдання за суттю схоже на 9 і 10 . Тільки замість  вбудованого класу *UserDict(клас словників) і *UserList(клас списків)
            # ми використаємо вбудований клас *UserString-(клас рядків/стрічок/*str) . І попрактикуємося з ними. 
            # Самі механізми робти з *UserString будуть аналогічні *UserDict. Дивись детальніший опис чому так в 9 завданні.

# from collections import UserString  # З бібліотеки *collections імпортуємо вбудований клас *UserString - 
#                         # - це клас в якому реалізовано всі методи рядків/стрічок/*str(*.strip(символ), *.lower(), *.split(символ) ...тощо)
#                         # Поле *data - буде містити переданий рядок, *self.data - посилання на ці дані для субкласів.


# class NumberString(UserString): # Створення і реалізація класу *NumberString що є субкласом для класу *UserString(клас *str) з бібілотеки *collections
#     ''' Субклас *NumberString, в дані реалізації, немає своїх полів , успадковує всі поля і методи від батьківського *UserString(клас *str)  
#          Має один свій власний метод *number_count() - без аргументів. 
#          повертає кілкість  чисел з переданого рядка  '''
    
#     def number_count(self):   # Реалізація власного методу *.number_countt() для екзеплярів *NumberString
#         ''' Метод(функція) без аргументів, рахує всі  числа з переданого в *data рядка і повертає їх кількість.
#           Якщо чисел не містить рядок , поветає 0. '''
        
#         count = 0            # Лічилький в якому будемо рахувати числа з рядка , Початковое значення 0 
        
#         for i in self.data:  # Цикл в якому будемо проходитись по елементах рядка *data(по кожному символу рядка) і 
#                              # і якщо елемент цифра будемо зібльшувати на одинцю наш лічильник *count 
# #                            # *self.data - це звернення до батьківського поля яке буде містити наш рядок екзепляру субкласу *NumberString 
#             if i.isdigit():  # Умова , поточний елемент(символ з рядка) перевряємо стандартним методом рядків *.isdigit()
#                              # *.isdigit()- повертає *True якщо рядок складається з цифр, інакше *False 
#                              # Оскільки наш поточний рядок *і це є поточний смивол з рядка *data , то як він буде цифрою - *.isdigit() - поверне *True 
#                 count += 1   # Якщо умова виконаась збільшуємо лічильник на 1 . 
#         return count         # По закінчню цикла *count буде містити кіькість цифр які були в нашому рядку *data. Його і повертаємо.

# # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) +++

# some_str_class = NumberString("")  # Тестовий екзепляр класу *NumberString, задаємо значеня пустий рядок. 
#                     # Примітка : пусті дужки залишати не можна видає помилку, можна зробти ще такий запис *some_str_class = *NumberString(UserString) 
#                                  # Єдина відміність, при даній реалізації класу *NumberString, 
#                                  # що крім всіх стандартних методів рядка, до нього можна застосувати власний метод субкласу *.number_count()

# # Передамо в наш тестовий езепляр якийсь звичайний рядок *some_str - # щоб переконатись що він поводить себе як звичайний рядок/стрічка/*str,
#  # але для нього буде працювати ще й власний метод класу *.number_count().

# some_str = "\nСьогодні я добре попрацював год 5 . Розібрався з 3-ма класами UserString, Userlist, Userdict .Виконав 11 завдань "

# some_str_class = NumberString(some_str) # передамо наш звичайний рядок *some_str в наш екзкпляр *some_str_class
# print(some_str_class)  # Принтимо результат #  Сьогодні я добре попрацював год 5 . Розібрався з 3-ма класами UserString, Userlist, Userdict .Виконав 11 завдань 
# print(some_str_class.upper()) # Застосуємо стандарий метод рядків *.upper()
#                               #  СЬОГОДНІ Я ДОБРЕ ПОПРАЦЮВАВ ГОД 5 . РОЗІБРАВСЯ З 3-МА КЛАСАМИ USERSTRING, USERLIST, USERDICT .ВИКОНАВ 11 ЗАВДАНЬ

# some_str_class = some_str_class + "\nАле ще попрацюю трішки!!!" # Добавимо до нашого екзепляра ще якийсь текст,
# print(some_str_class) # Принтимо результат . # Сьогодні я добре попрацював год 5 . Розібрався з 3-ма класами UserString, Userlist, Userdict .Виконав 11 завдань 
#                                              # Але ще попрацюю трішки!!!
 
# # З прикладів вище, ми переконались що наш екзепляр *some_str_classt працює аналогічно будь якому іншому рядку/*str , 
# # про те він підтримує і наш власний метод *.number_count() якого не має в жодному іншому *str. 
# #  Примітка : що робить власний  метод **.number_count() класу *NumberString дивись в реалізації цього методу в даному класі в коді вище
# #               # в частині що містить опис і реалізацію класу *NumberString(UserString) .

# print(some_str_class.number_count()) # Принтимо резульат # Виведе 4 оскільки в нашому *some_str_class міститься 4 цифри. 5, 3, 1, 1


# ================================ Звдання 12 / Task 12  ======================================

# ================================   Власні винятки .Exceptions  =======
                                            
#                                      **class Exceptions**

# У Python широко використовується механізм виключень (Exceptions) для того, 
# щоб дати зрозуміти зухвалому коду, що саме пішло не так і що з цим робити. 
# На виключеннях у тому числі будують розгалуження коду, наприклад ми очікуємо, що користувач введе саме число, 
# але він може ввести що завгодно:

# def input_number():
#     while True:
#         try:
#             num = input("Enter integer number: ")
#             return int(num)
#         except:
#             print(f'"{num}" is not a number. Try again')


# num = input_number()
# У цьому прикладі функція input_number вийде з нескінченного циклу тільки, коли користувач введе ціле число. 
# Це приклад використання винятків у Python з метою управління потоком виконання.

# Коли ж ви пишете свою програму, вам може знадобитися створити свої власні винятки, щоб обробляти їх на вищому рівні. 
# Наприклад, ви очікуєте, що користувач повинен ввести ім'я, і це ім'я не повинно бути коротшим трьох символів
# і починатися з великої літери. Ви можете створити власний виняток, який буде викликатися, 
# якщо введення користувача не пройшло цю перевірку. Тоді будь-який код, який викликатиме цю функцію, 
# зможе коректно обробити цей конкретний випадок.

# import string

# class NameTooShortError(Exception):
#     pass

# class NameStartsFromLowError(Exception):
#     pass

# def enter_name():
#     name = input("Enter name: ")
#     if len(name) < 3:
#         raise NameTooShortError
#     if name[0] not in string.ascii_uppercase:
#         raise NameStartsFromLowError


# while True:
#     try:
#         name = enter_name()
#         break
#     except NameTooShortError:
#         print('Name is too short, need more than 3 symbols. Try again.')
#     except NameStartsFromLowError:
#         print('Name should start from capital letter. Try again.')

# У цьому прикладі ми створили власні винятки, успадковуючи батьківський клас для всіх винятків у Python — клас Exception. 
# Далі у коді коректно обробили два випадки, коли користувач ввів занадто коротке ім'я, 
# або коли ім'я починається не з великої літери.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас IDException, який успадковуватиме клас Exception.

# Також реалізуйте функцію add_id(id_list, employee_id), яка додає до списку id_list ідентифікатор користувача employee_id 
# та повертає вказаний оновлений список id_list.

# Функція add_id буде викликати власне виключення IDException, якщо employee_id не починається з '01', 
# інакше employee_id буде додано до списку id_list.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class IDException(Exception): # Створюємо пустий субклас *IDException батьківський клас *Exception
#     ''' Субклас *IDException, реалізація пустий клас, наслідує всі атрибути батьківського *Exception - в якому реалізовано 
#      робота з всіма опраторами виключень(помилок) таких як try: excecp:, else: , finally: '''
# # Примітка : Оскільки клас пустий , то фактично ми придумуємо довільне імя класу,
#             # щоб воно хоч якось нагадувало ту помилку яку хочемо опрацювати в особливий спосіб.
#             # В нашому випадку IDException(IDвиключення) - бо будемо опрацьовувати помилку невірно введеного ID.
#             # Для чого і коли використовувати читай теорію до цього завдання там все зрозуміло описано. 
#             # Мабудь часто прийдеться застосовувати.Для розуміння виглядає не складно.
#             # Схема : # Оголошуємо потрібний нам клас винятку : # class *ЯкесьІмяЯкеОписуєХочЯкосьВиключення(Exception): 
#                                                                 #     pass # Оператор "пустоти" :))).
#                       # Далі в коді створюємо Умову яка перевіряє наші дані на "правільність" , 
#                       # якщо дані нам не підходять викликаємо самі помилку через опратора *raise *ЯкесьІмяЯкеОписуєХочЯкосьВиключення
#                       # Ту частину коду де виникає виключення опрацьовуємо try: expect: (за потреби всіма опраторами що ловлять помилки в коді) 
#                       # в блоці опратора *expect *ЯкесьІмяЯкеОписуєХочЯкосьВиключення :
#                       #                     print("Що ми хочемо сказати користувачу !!!!!")
#     pass  # Оператор "пустоти" -(власне визначення \(**)/ )


# def add_id(id_list, employee_id): # Опис звичайної функції :).
#     '''Функція яка приймає два аргумети, 
#     перший *id_list(тип*list) - список id робітників, 
#     другий *employee_id(тип*str) - id нового працівника, 
#     Якщо працівник вів правильно свій id то повертає список всіх хто до нього це зробив успішно + його
#     Якщо не вірно то просить його вести вірно , Цикл безкінечний - вихід правильно введене id.
#     Умова правильності це спочатку ввести 01 а вже далі своє id.  '''

#     if employee_id.startswith('01') : # Умова за допомогою методу *.startswith('якийсь_шаблон') 
#                                       # Перевіряєм чи починається  наш рядок *employee_id на "01"
#         id_list.append(employee_id)   # Якщо умова виконалась , додаєм наш *employee_id до нашого списку *id_list. 
#         return id_list                # Повертаємо наш список *id_list з функції . 
#     else:                   # Якщо умова не виконалась викликамо виняток. 
#         raise IDException   # Виклик нашого власного виянтку *IDException оператором *raise 

# # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++

# id_list = ["01#12458", "01#121212", "01#aaaaaa" ] # Якийсь тестовий список 

# while True :  # Бескінечний цикл в якому будемо просити ввести id згідно шаблону.
#               # Вихід - оператор *break коли введуть правильно *id
#     try: # Оператор перехоплення винятків/помилок 

#         employee_id_input = input("\nВВедіть ваш id за шаблоном: 01#ваш_id\n ") # *employee_id_input - отримає те що введуть з клавіатури.
#         print(add_id(id_list,employee_id_input)) # Якщо введ правильно, то відразу повернем на екран результат роботи функції *add_id(id_list,employee_id_input)
#                                                  # якщо введе не правиильно, викличеться наша помилка яку перехопить відразу try: 
#             # і відправить на переврку в *expect, *expect - опрацьовує всі стандартні помилки (дивись модуль 2 , розділ Винятки або в інтернеті)
#             # а також ті що будуть містити клас *Exception . В нашому випадку *IDException
#                                              
#         break  # Оператор примусового припинення циклу. Відразу завершить цикл .
    
#     except IDException: # Опрацювання винятку . В нашому випадку просто принтимо. 
#                         # Оскільки try: expect: знаходяться в середені безкінечного циклу *while . 
#                         # То після того як виведе текст з принта, повернеться на початок циклу, а там введть дані згідно шаблону ).
#         print(f"Невірний шаблон, добавте перед вашим id 01") # Принтимо підсказку що пішло не так .

# ================================ Звдання 13 / Task 13  ======================================

# ================================   Поліморфізм / Качина типізація  =======

# Качина типізація — це механізм, властивий Python, який дозволяє використовувати будь-які об'єкти один замість іншого, 
# аби в обох були потрібні методи та поля. Качиною ця типізація називається від 
# приказки: "Якщо крякає як качка, плаває як качка і літає як качка, це качка". 
# Це добре відображає суть підходу, реалізованого у Python. Ні, інтерпретатор не перевіряє, 
# що на функцію або метод був переданий об'єкт потрібного або дочірнього класу, достатньо щоб у 
# об'єкта були потрібні методи і все буде працювати.

# class Mammal:
#     phrase = ''

#     def voice(self):
#         return self.phrase

# class Dog(Mammal):
#     phrase = 'Bark!'

# class Cat(Mammal):
#     phrase = 'Meow!'

# class Chupakabra:
#     def voice(self):
#         return 'Whooooo!!!'

# class Recorder:
#     def record_animal(self, animal):
#         voice = animal.voice()
#         print(f'Recorded "{voice}"')

# r = Recorder()
# cat = Cat()
# dog = Dog()
# strange_animal = Chupakabra()

# r.record_animal(cat)  # Recorded "Meow!"
# r.record_animal(dog)  # Recorded "Bark!"
# r.record_animal(strange_animal)  # Recorded "Whooooo!!!"
# В цьому прикладі ми створили батьківський клас Mammal, у якого є метод voice та два дочірніх до нього Dog та Cat. 
# Клас Record приймає на вхід методу record_animal об'єкт animal і викликає у нього метод voice, 
# щоб вивести результат виконання voice у консоль. При цьому є клас Chupakabra, у якого теж є метод voice, 
# та хоч він і не успадковується від Mammal, але об'єкти цього класу так само можна передавати в record_animal. 
# Головне, щоб атрибут називався так само і приймав ті ж аргументи (якщо це метод).

# Сенс качиної типізації полягає в тому, щоб не дбати про точний клас об'єкта, а дбати про те, 
# які методи для нього можна викликати та які операції над ним можна виконувати. 
# Таким чином, треба просто передати об'єкт методу, знаючи, що при неправильному використанні буде викинуто виключення.

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Як ми вже говорили, поліморфізм - це здатність програми вибирати різні реалізації при виклику операцій з однією і тією ж назвою.

# Але поліморфізм - це також здатність об'єктів прикидатись чимось іншим. 
# У наведеному вище прикладі Chupakabra прикидалася собакою та кішкою.

# Для коду із завдання вам необхідно реалізувати клас CatDog, не використовуючи успадкування від класу Animal, 
# але щоб екземпляр класу CatDog поводився як і, як екземпляр класу Cat, тобто. він повинен вдати, що він клас Cat.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # Створення і реалізація батьківського класу (*суперклас) *Animal. Опис дивись в 4 завдані.
#     '''Батьківський клас *Animal , містить свій контсруктор(__init__)  в якому описано два обовязкових поля *nickname, *weight
#     В даній реалізації , має також два власні методи , 
#     *.say()- пустий метод і 
#     *.change_weight(*ags)- міняє поле *weight на значення *ags в екзеплярі класу *Animal  '''
    
#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass

#     def change_weight(self, weight):
#         self.weight = weight
#         return weight


# class Cat(Animal): # Створення і реалізація субкласу *Cat батьківського класу *Animal. 
#     ''' Субклас *Cat, вданій реалізації , не містить жодного свого поля, всі атрибути наслідує від *Animal.
#     Має тільки модифікований метод *.say() - який, на відміну від батьківського, повертає "Meow",
#     якщо його застосувати до екзепляру *Cat '''
    
#     def say(self): # Модифікований метод *.say() - повертає *"Meow", якщо його застосувати до екзепляру класу *Cat
#         return "Meow"


# class CatDog: # Створення і реалізація батьківського класу (*суперклас) *CatDog
#     ''' Батьківський клас *CatDog - (не путати з всіма попердніми *CatDog він з ними не має нічого спільного, ті були підкласами і в інших завданнях ,а цей supperklass )
#     Має свій власний конструктор(__init__) , свої власні два обовязкові поля *nickname, *weight - (ці поля власні, не спадкуються ні відкого хоча називаються аналогічно класу *Anamal)
#     і три власні методи ,
#     *.say() - пустий метод ,
#     *.change_weight(*args) - приймає один аргумент і міняє власне поле *weight на значення в *args для екзеплярів *CatDog ,
#     *.imitcat(*args) -      '''

#     def __init__(self, nickname, weight):
#         self.nickname = nickname
#         self.weight = weight

#     def say(self):
#         pass  

#     def change_weight(self, weight):
#         self.weight = weight
#         return weight

#     def imitcat(self, cat_imit):
#         cat_imit_say = cat_imit.say()
#         return cat_imit_say
    
    
# # # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++

# cat_original = Cat("Mur-Mur", 15) # Тестовий екзепляр субкласу *Cat Наслідує всі атрибути *Animal, має модифікований метод *say() 
# print(cat_original.nickname, cat_original.weight) # Принтемо результа окремо для полів          #  Mur-Mur 15
# print(cat_original.say(), cat_original.change_weight(7)) # Принтемо результа окремо для методів #  Meow 7

# cat_imit_CatDog = CatDog("Mur-Gav", 55) # Тестовий екзепляр суперкласу *CatDog , нічого не наслідує, все має своє,
#                     # має унікальний метод *.imitcat(*args) - який повертає результат, той що містить клас який передається як аргумент
#                     # Якщо передати не клаб, або клас, який передається як аргумант, не має методу *.say() - виклкиче системний збій нашого коду  

# print(cat_imit_CatDog.nickname, cat_imit_CatDog.weight) # Принтемо результа окремо для полів 
# # Виведе:  Mur-Gav 55
# print(cat_imit_CatDog.say(), cat_imit_CatDog.change_weight(32), cat_imit_CatDog.imitcat(cat_original)) # Принтемо результа окремо для методів #
# # Виведе:  None 32 Meow . де # *None - бо власний метод *.say() - нічого не повертає 
#                              # *32 - бо *.change_weight(32)- міняє власне поле *weight
#                              # *Meow - бо метод *.imitcat(cat_original) містить екзепляр *Cat в якому є модернізований метод *say() який повертає *Meow



# ================================ Звдання 14 / Task 14  ======================================

# ================================   КОНТАКТНА КНИГА, ЧАСТИНА ПЕРША  =======

# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# Реалізуйте клас Contacts, який працюватиме з контактами. На першому етапі ми додамо два методи.
# list_contacts повертає список контактів це змінна contacts з поточного екземпляра класу
# add_contacts додає новий контакт до списку, який є змінною об'єкту - contacts
# Клас Contacts містить змінну класу current_id.
# Ми будемо використовувати її при додаванні нового контакту як унікального ідентифікатора контакту. 
# Коли ми додаємо новий контакт, то передаємо такі аргументи в метод add_contacts: name, phone, email та favorite. 
# Метод повинен створити словник із зазначеними ключами та значеннями параметрів функції. 
# Також необхідно додати до словника новий ключ id, значенням якого є значення змінної класу current_id.

# Приклад отриманого словника:

#     {
#     "id": 1,
#     "name": "Wylie Pope",
#     "phone": "(692) 802-2949",
#     "email": "est@utquamvel.net",
#     "favorite": True,
# }
# Вказаний словник ми додаємо до списку contacts.
# Не забуваймо збільшувати змінну current_id на одиницю після кожного виклику методу add_contacts 
# для збереження унікальності ключа id для словника.
# Примітка: для правильного проходження тесту не створюйте екземпляр класу в коді.

# ++++++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

class Contacts: # Створення і реалізація батьківського класу (*суперклас) *Contacts 
    '''Батьківський клас *Contacts, має одне не обовязкове поле *current_id - початкове значення 1 .
    Меє свій конструктор(__init__) з пустим полем,  принймає список, де елементи софрмовані словники власним методом *.add_contacts( name, phone, email, favorite)
    додає цей словник до списку *contacts, значення якого, по замовчуванню, пустий список
    Має два своїх методи :
    *.list_contacts()- без аргументів, повертає поточний список що містить *self.contacts 
    *.add_contacts( name, phone, email, favorite) - приймає  4 аргументи , 
                формує словник заданого типу *{"id": 1, "name": "Wylie Pope", "phone": "(692) 802-2949","email": "est@utquamvel.net", "favorite": True}
                додає його у наш список contacts і повертає відразу список з доданим контактом (тип словник)
                Тобто наш список *contacts буде містити, як елементи, словникаи заданого типу   '''
    
    current_id = 1  # Не обовязкове поле *current_id класу *Contacts . Доступ до поля через метод класу ,*Contacts.current_id

    def __init__(self): # Власний коструктор , без обовязкових полів , приймає  список  *self.contacts, Значення за замовчуванням пустий []
        self.contacts = [] # Посиляння на *self.contacts список , Позамовчуванню пустий.

    def list_contacts(self): # Власний метод *.list_contacts()- без аргументів. Повертає посилання на наш список *self.contacts(примітка, список формується за допомогою власного методу класу ) 
        return self.contacts # Повертаємо посилання на список *self.contacts 
        

    def add_contacts(self, name, phone, email, favorite): # Власний метод *.add_contacts( name, phone, email, favorite) - містить 4 аргументи - це відповідних ключів словника.
        '''Власний метод класу *Contacts , приймає 4 аргументи, З них формує відповідного формату словник(формат дивись в умові завдання)
        Де перша пара з ключ : значення , має наступний вигляда: 'id': Contacts.current_id , Сформований словник додає до нашого списку *self.contacts
        Збільшує значення поля *current_id на 1 , повертає наш список *self.contacts з методу'''                    
        
        contact_dict ={} # Словник в який будемо формувати пари ключ : значення выдповідно до вимог завдання. Початкове значення пустий *{}.
        contact_dict['id'] = Contacts.current_id # Формуємо першу пару словника *contact_dict, має наступний вигляда: 'id': Contacts.current_id 
        contact_dict["name"] =  name             # Формуємо наступну пару словника *contact_dict, має наступний вигляда: 'name': name
        contact_dict["phone"] = phone            # Формуємо наступну пару словника *contact_dict, має наступний вигляда: 'phone': phone 
        contact_dict["email"] = email            # Формуємо наступну пару словника *contact_dict, має наступний вигляда: 'email': email
        contact_dict["favorite"] = favorite      # Формуємо наступну пару словника *contact_dict, має наступний вигляда: 'favorite': favorite
        self.contacts.append(contact_dict)       # LДодаємо наш сформований словик в список *self.contacts
        Contacts.current_id += 1                 # Змінюємо значення не обовязкового поля *current_id на один.
        return self.contacts                # Повертаэмо результат.

# Примітка : можна написати красивіше останій метод. Все те саме але красивіше )). Підгледів у інших.
    # def add_contacts(self, name, phone, email, favorite):
    #     new_contact = { 
    #         "id": Contacts.current_id,
    #         "name": name,
    #         "phone": phone,
    #         "email": email,
    #         "favorite": favorite,

    #     }
    #     Contacts.current_id += 1
    #     return self.contacts 
      

# ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++
some_contacts = Contacts() # Екзкпляр класу *Contacts

print(some_contacts.list_contacts()) # Принтимо результат роботи методу *.list_contacts() # *[] , Оскільки ми ще не додавали жодних значень, наш список відповідно порожній. 
print(some_contacts.add_contacts('Andrew', "(692) 802-2949", "est@utquamvel.net", True )) # Додаємо значення методом *.add_contacts(*name, *phone, *email, *favorite)
# Принтимо : 
print(some_contacts.list_contacts()) #  *[{'id': 1, 'name': 'Andrew', 'phone': '(692) 802-2949', 'email': 'est@utquamvel.net', 'favorite': True}]

print(some_contacts.add_contacts('Volodymyr', "(096) 305-1648", "kub@utquamvel.net", True )) # Додаємо ще значення методом *.add_contacts(*name, *phone, *email, *favorite)
# Принтимо :
print(some_contacts.list_contacts())
[{'id': 1, 'name': 'Andrew', 'phone': '(692) 802-2949', 'email': 'est@utquamvel.net', 'favorite': True}, 
 {'id': 2, 'name': 'Volodymyr', 'phone': '(096) 305-1648', 'email': 'kub@utquamvel.net', 'favorite': True}]