# ===================  Home work 10 ========================

# +++++++++++++++++++++++++++++  Основи роботи з класами # Об'єктноорієнтоване програмування (ООП) ++++++++++++++++++++++++++++++++++++++

#                     1. Визначення та створення класу
#                     2. Створення об'єктів
#                     3. Атрибути класу (поля та методи)
#                     4. Конструктор класу
#                     5. Наслідування
#                     6. Method Resolution Order (MRO).
#                     7. Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString).
#                     8. Власні винятки
#                     9. Поліморфізм / Качина типізація


# ================================ Звдання 1 / Task 1 ======================================

# ================================  Визначення та створення класу. ==========================

# Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, 
# називають об'єктноорієнтованою парадигмою програмування.
# Об'єктноорієнтоване програмування (ООП) по праву вважається однією з найефективніших методологій створення програмних продуктів.
# Ви пишете класи, що описують реально чинні предмети та ситуації, а потім створюєте об'єкти на основі цих описів.

# Покажемо найпростіший клас на наступному прикладі.

# class Person:
#     pass  # Порожній блок


# p = Person()
# Ми створюємо новий клас за допомогою оператора class та імені класу. За цим слідує блок виразів, 
# що формують тіло класу. В нашому випадку блок у нас порожній, на що вказує оператор pass.
# Далі ми створюємо об'єкт-екземпляр класу, записуючи ім'я класу з дужками.

# ООП має чотири основні концепції, які відрізняють його від інших методологій програмування:

# Абстракція
# Інкапсуляція
# Наслідування
# Поліформізм
# З чотирьох концепцій ми розберемо у завданнях три останні, крім абстракції. 
# Це більш просунута категорія, і створення абстрактних класів ми розглядатимемо в другому блоці навчання. 
# Зараз нагадаю йде перший блок Python. Коротко тільки зауважимо, що:

# Абстракція - це модель якогось об'єкта або явища з реального світу, що відкидає незначні деталі, 
# які не грають істотну роль в цьому контексті.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. 
# Також створіть екземпляр класу Animal (замість реалізації класу можете використовувати pass) і привласніть змінній animal.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
#    pass        # якщо в реалізації класу є тільки оператор *pass - то це пустий клас. Реалізація класу - це як код оголошення функції , 
#                # Починається після двокрапки з нового рядка і з відступом в табуляцію або 4 пробіли. 

# animal = Animal() # зміній *animal присвоюємо пустий екземпляр класу *Animal 


# ================================ Звдання 2 / Task 2 ======================================

# ================================   Створення об'єктів ==========================

# Об'єкти можуть зберігати дані у звичайних змінних, які належать об'єкту. 
# Змінні, що належать об'єкту або класу, називають полями. Об'єкти можуть мати функції, які належать класу. 
# Такі функції називають методами класу. Всі разом (поля та методи) заведено називати атрибутами класу.

# За допомогою атрибутів класу ми виконуємо інкапсуляцію — приховуємо деталі реалізації під інтерфейсом класу.

# Інкапсуляція — це здатність об'єктів приховувати частину свого стану та поведінки від інших об'єктів, 
# надаючи зовнішньому світу лише певний інтерфейс взаємодії із собою.

# Методи класу мають одну відмінність від звичайних функцій: вони повинні мати додатково ім'я, 
# яке додається до початку списку параметрів. 
# Однак, при виклику методу ніякого значення цьому параметру привласнювати не потрібно його вкаже Python. 
# Ця змінна вказує на сам об'єкт екземпляра класу, і за традицією вона називається self.

# class Person:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def greeting(self):
#         return f"Hi {self.name}"


# p = Person("Boris", 34)
# Метод __init__() - спеціальний метод, 
# який автоматично виконується під час створення кожного нового екземпляра на базі класу Person (конструктор). 
# Ім'я методу починається та закінчується двома символами підкреслення. 
# Причина у тому, що так ми запобігаємо конфліктам імен стандартних методів Python і методів ваших класів.

# Коли ми створюємо екземпляр Person, Python викликає метод __init__() з класу Person. 
# Ми передаємо в Person() ім'я "Boris" та вік 34 як аргументи. 
# Значення self буде передано автоматично, явно передавати його не потрібно.

# Зверніть увагу, що метод класу greeting не приймає параметрів, проте має параметр self у визначенні функції.



# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. Також створіть екземпляр класу Animal та привласніть змінній animal.
# Для класу Animal у конструкторі створіть дві властивості: nickname - кличка тварини та 
# weight - вага тварини. Реалізуйте також метод класу say. 
# При реалізації методу можна використати оператор pass, поки що головне - це визначення, а не конкретна реалізація.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
   
   def __init__ (self, nickname, weight): # Конструктор (це функція імя якої починається і закінчується з подвійних підкреслень) 
                                           # Першим аргументом конструктора завжди є зміна *self, далі може йти довільна кількість аргументів.
                                           # Оголошення всіх довільних аргументів починається завжти зміною *self.
        self.nickname = nickname # Оголошення *nickname  #Оголошення аргументів конструктора відбувається через зміну *self.
        self.weight = weight     # Оголошення *weight  #Оголошення аргументів конструктора відбувається через зміну *self.

   def say(self):  # Створення методу класу . імя методу класу не починається з подвійного підкреслення 
                   # та викликається через крапку в тілі коду (приклад animal.say(*якесь_занчення) ),
                   # Метод може приймати аргументи (їх кількість ргулюється кількістю аргументів *self в описі методу класу )
                   # або бути без аргументів # Приклад : def say(): 
                   # В нашому випадку реалізуєм пустий метод . Тому в тілі методу використовуємо тільки оператор *pass який приймає один аргумент довільного типу.
        pass       # Оператор *pass - ігнорує код в блоці в якому заданий . Використовуємо для ігнорування частини коду логіка якого ще непрописана. 
                   # Щоб інтерпритатор Python не видавав помилок при запуску цього блоку коду .   
               

animal = Animal("Linda", 25) # зміній *animal присвоюємо  екземпляр класу *Animal який містить два заданих  аргумента. 
                            #  Animal("Linda", 25) де # *Animal - це імя класу . 
                                                      # *"Linda" - заданий  аргумент *nickname *class Animal
                                                      # *25 - заданий аргумент *weight *class Animal 
