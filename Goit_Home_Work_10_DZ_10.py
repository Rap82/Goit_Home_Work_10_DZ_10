# ===================  Home work 10 ========================

# +++++++++++++++++++++++++++++  Основи роботи з класами # Об'єктноорієнтоване програмування (ООП) ++++++++++++++++++++++++++++++++++++++

#                     1. Визначення та створення класу
#                     2. Створення об'єктів
#                     3. Атрибути класу (поля та методи)
#                     4. Конструктор класу
#                     5. Наслідування
#                     6. Method Resolution Order (MRO).
#                     7. Контейнери, створені за допомогою наслідування (UserList, UserDict, UserString).
#                     8. Власні винятки
#                     9. Поліморфізм / Качина типізація


# ================================ Звдання 1 / Task 1 ======================================

# ================================  Визначення та створення класу. ==========================

# Спосіб організації програм, коли об'єднують дані та функціонал усередині якогось об'єкта, 
# називають об'єктноорієнтованою парадигмою програмування.
# Об'єктноорієнтоване програмування (ООП) по праву вважається однією з найефективніших методологій створення програмних продуктів.
# Ви пишете класи, що описують реально чинні предмети та ситуації, а потім створюєте об'єкти на основі цих описів.

# Покажемо найпростіший клас на наступному прикладі.

# class Person:
#     pass  # Порожній блок


# p = Person()
# Ми створюємо новий клас за допомогою оператора class та імені класу. За цим слідує блок виразів, 
# що формують тіло класу. В нашому випадку блок у нас порожній, на що вказує оператор pass.
# Далі ми створюємо об'єкт-екземпляр класу, записуючи ім'я класу з дужками.

# ООП має чотири основні концепції, які відрізняють його від інших методологій програмування:

# Абстракція
# Інкапсуляція
# Наслідування
# Поліформізм
# З чотирьох концепцій ми розберемо у завданнях три останні, крім абстракції. 
# Це більш просунута категорія, і створення абстрактних класів ми розглядатимемо в другому блоці навчання. 
# Зараз нагадаю йде перший блок Python. Коротко тільки зауважимо, що:

# Абстракція - це модель якогось об'єкта або явища з реального світу, що відкидає незначні деталі, 
# які не грають істотну роль в цьому контексті.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. 
# Також створіть екземпляр класу Animal (замість реалізації класу можете використовувати pass) і привласніть змінній animal.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
#    pass        # якщо в реалізації класу є тільки оператор *pass - то це пустий клас. Реалізація класу - це як код оголошення функції , 
#                # Починається після двокрапки з нового рядка і з відступом в табуляцію або 4 пробіли. 

# animal = Animal() # зміній *animal присвоюємо пустий екземпляр класу *Animal 


# ================================ Звдання 2 / Task 2 ======================================

# ================================   Створення об'єктів ==========================

# Об'єкти можуть зберігати дані у звичайних змінних, які належать об'єкту. 
# Змінні, що належать об'єкту або класу, називають полями. Об'єкти можуть мати функції, які належать класу. 
# Такі функції називають методами класу. Всі разом (поля та методи) заведено називати атрибутами класу.

# За допомогою атрибутів класу ми виконуємо інкапсуляцію — приховуємо деталі реалізації під інтерфейсом класу.

# Інкапсуляція — це здатність об'єктів приховувати частину свого стану та поведінки від інших об'єктів, 
# надаючи зовнішньому світу лише певний інтерфейс взаємодії із собою.

# Методи класу мають одну відмінність від звичайних функцій: вони повинні мати додатково ім'я, 
# яке додається до початку списку параметрів. 
# Однак, при виклику методу ніякого значення цьому параметру привласнювати не потрібно його вкаже Python. 
# Ця змінна вказує на сам об'єкт екземпляра класу, і за традицією вона називається self.

# class Person:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def greeting(self):
#         return f"Hi {self.name}"


# p = Person("Boris", 34)
# Метод __init__() - спеціальний метод, 
# який автоматично виконується під час створення кожного нового екземпляра на базі класу Person (конструктор). 
# Ім'я методу починається та закінчується двома символами підкреслення. 
# Причина у тому, що так ми запобігаємо конфліктам імен стандартних методів Python і методів ваших класів.

# Коли ми створюємо екземпляр Person, Python викликає метод __init__() з класу Person. 
# Ми передаємо в Person() ім'я "Boris" та вік 34 як аргументи. 
# Значення self буде передано автоматично, явно передавати його не потрібно.

# Зверніть увагу, що метод класу greeting не приймає параметрів, проте має параметр self у визначенні функції.



# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Створіть клас Animal. Також створіть екземпляр класу Animal та привласніть змінній animal.
# Для класу Animal у конструкторі створіть дві властивості: nickname - кличка тварини та 
# weight - вага тварини. Реалізуйте також метод класу say. 
# При реалізації методу можна використати оператор pass, поки що головне - це визначення, а не конкретна реалізація.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal:  # створення класу , де *class - вбудована функція для  оголошення класу , *Animal імя класу який створюємо.
   
#    def __init__ (self, nickname, weight): # Конструктор (це функція імя якої починається і закінчується з подвійних підкреслень) 
#                                            # Першим аргументом конструктора завжди є зміна *self, далі може йти довільна кількість аргументів.
#                                            # Оголошення всіх довільних аргументів починається завжти зміною *self.
#         self.nickname = nickname # Оголошення *nickname  #Оголошення аргументів конструктора відбувається через зміну *self.
#         self.weight = weight     # Оголошення *weight  #Оголошення аргументів конструктора відбувається через зміну *self.

#    def say(self):  # Створення методу класу . імя методу класу не починається з подвійного підкреслення 
#                    # та викликається через крапку в тілі коду (приклад animal.say(*якесь_занчення)),
#                                        
#       pass         # В нашому випадку реалізуєм пустий метод . Тому в тілі методу використовуємо тільки оператор *pass який приймає один аргумент довільного типу.
#                    # Оператор *pass - ігнорує код в блоці в якому заданий . Використовуємо для ігнорування частини коду логіка якого ще непрописана. 
#                    # Щоб інтерпритатор Python не видавав помилок при запуску цього блоку коду .   
               

# animal = Animal("Linda", 25) # зміній *animal присвоюємо обєкт(*екземпляр_класу) *Animal який містить два заданих  аргумента. 
#                             #  Animal("Linda", 25) де # *Animal - це імя класу . 
#                                                       # *"Linda" - заданий  аргумент *nickname *class Animal
#                                                       # *25 - заданий аргумент *weight *class Animal 


# ================================ Звдання 3 / Task 3  ======================================

# ================================   Атрибути класу (поля та методи) ==========================

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Для попереднього завдання реалізуйте в класі Animal метод change_weight, який має змінювати вагу тварини.

# Викличте функцію change_weight(12) для об'єкта animal та змініть значення початкової ваги з 10 на 12 одиниць.


# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# class Animal: # Оголошення власного класу з іменем  *Animal 
#               # клас може містити поля та методи, поля це зміні в класі, методи це описані функції в класі, 
#               # Методи є двох типів :
#                                 # Методи класу (описуються в контструкторі) і
#                                 # методи обєків (описуються в інших функціях класу) Тобо *підметод(власне визначення:) )
    
#     def __init__(self, nickname, weight): # Конструктор класу в якому задаємо методи класу *class Animal
#         self.nickname = nickname          # Оголошення методу класу *nickname  #Оголошення аргументів конструктора відбувається через зміну *self.
#         self.weight = weight              # Оголошення методу класу *weight  #Оголошення аргументів конструктора відбувається через зміну *self 

#     def say(self): # Пустий метод обєекту
#         pass

#     def change_weight(self, vaga): # Оголошення методу *change_weight для обєкту *weight, *class Animal
#         self.weight = vaga         # Присвоюємо значення *vaga , яке буде отримане з методу *change_weight , полю *self.weight класу *class Animal 
         
        

# animal = Animal("Simon", 10) # змінії *animal присвоюємо екземпляр(обєкт) класу *Animal("Simon", 10) 
#                              # з визначеними значеннями полів *nickname ="Simon" , *weight = 10
# print(animal)

# animal.change_weight(12)      # стверений метод *.change_weight(12) - змінить  поточне значення поля *weight в екземплярі *animal
#                               # де *.change_weight(12)- власний метод обєкта *weight з значенням аргумета *12, 
#                               # а  *animal - зміна що містить екземпляр створеного класу *class Animal. # *animal = *<__main__.Animal object at 0x0000017DC20BA780>
                             
# simon_weight = animal.weight  # Повертаємо в *simon_weight значення поля *weight за допомогою створеного методу каласу *.weight для *class Anima  # *simon_weight == 12 для нашого прикладу

# print(simon_weight)    # Принтимо результат # *12


# ================================ Звдання 4 / Task 4  ======================================

# ================================   Конструктор класу ==========================

# Існує два типи полів: змінні класи та змінні об'єкта. Як видно з назви вони відрізняються тим, 
# що належать або класу чи об'єкту відповідно.

# Змінні класу – доступ до них мають усі екземпляри цього класу. Змінна класу існує тільки одна, та будь-який з об'єктів, 
# коли змінює змінну класу, змінює її для решти екземплярів цього ж класу.

# Змінні об'єкта - належать кожному окремому екземпляру класу. У цьому випадку кожен об'єкт має свою власну копію поля, 
# тобто вона жодним чином не пов'язана з іншими такими ж полями в інших екземплярах.

# Розглянемо наступний приклад:

# class Person:
#     count = 0

#     def __init__(self, name):
#         self.name = name
#         Person.count += 1

#     def how_many_persons(self):
#         print(f"Кількість людей зараз {Person.count}")


# first = Person('Boris')
# first.how_many_persons()
# second = Person('Alex')
# first.how_many_persons()
# Вивід:

# Кількість людей зараз 1
# Кількість людей зараз 2
# Тут count належить класу Person і є змінною класу. 
# Змінна name належить об'єкту та є змінною об'єкта, і надається значення за допомогою self. 
# Як бачимо з прикладу, звернення до змінної класу Person виконується як Person.count, 
# і ми не використовуємо звернення self.count. До змінної ж об'єкта name, у всіх методах цього об'єкта, 
# ми звертаємось за допомогою позначення self.name.

# Але якщо ми введемо змінну об'єкта з тим самим ім'ям, що й змінну класу, це зробить недоступною змінну класу!

# class Person:
#     count = 0

#     def __init__(self):
#         pass


# person = Person()
# print(person.count)  # 0
# Ми ще маємо доступ до змінної класу, а у наступному прикладі вже ні.

# class Person:
#     count = 0

#     def __init__(self):
#         self.count = 10


# person = Person()
# print(person.count)  # 10
# Примітка
# Але ми все ще маємо доступ до змінної через ім'я класу: `Person.count`




# ++++++++++++++++++++++++++++++++++++++ Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Додамо в клас Animal змінну класу color, значення якої спочатку дорівнює 'white', і метод change_color, 
# який повинен змінювати значення змінної класу color.

# Створіть екземпляри об'єкта: first_animal та second_animal

# Викличте функцію change_color("red") для будь-якого екземпляра об'єкту Animal та змініть значення змінної класу color на "red".

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

class Animal:

    color = "white" # не обовязкове значення поля *color для всіх екзеплярів класу *class_Animal, по замовчуванню задано "white".
                    # Це "прихована" змінна методу класу ,  не є обовязковою бо неоголошенна в конструкторі *__init__ 
                    # В самому екзеплярі її значення ні побачити, ні задати , ні змінити напряму не можливо. 
                    # ЇЇ значення можна повернути методом класу *.color і воно буде одинаковим для всіх екземплярів.
                    # Зміна значення зміної класу відбувається в середені реалізації класу , за наступною схемою :
                    # *Імя_класу.*зміна_класу = *зміна_що_містить_значення_яке_хочимо_присвоїти. 
            # Приклад: Animal.color = new_animal_color *(ДЛЯ НАШОГО ВИПАДКУ)
                    # Для заміни її значення зовні,  потрібно створювати окремий метод , в якому і будемо робити переприсвоєння . 
                    # Після заміни значення, воно буде одинаковим для всіх екзеплярів цього класу, 
                    # тобто не потрібно його міняти для кожного екзепляра цього класу і відповідно не можливо всатновити окремо її значення для окремого екземпляра цього класу.
                    # Дививсь нижче , оголошення методу *change_color(self, new_animal_color): - там і будемо мінти це значення.
            # Для нашого прикладу: # екзепляр *first_animal.color - поверне *white і *second_animal.color поверне також *white
                                   # Після застосовуння методу *.change_color("red") до хоча б одного екземпляра(*second_animal.change_color("red"))
                                   # стане  *first_animal.color - поверне *red і *second_animal.color поверне *red                 

    def __init__(self, nickname, weight): # Конструкор класу *class_Animal , вньому оголошуємо обовязкові поля для заданого класу.
        self.nickname = nickname   # Створення поля *self.nickname класу *class_Animal,
                                   # Такий запис означає що перше значення в екземплярі буде містити значення поля *nickname
                                   # Це дозволяє для нашого екзепляра застосувати метод класу *.nickname щоб отримати його значення.
            # Для нашого прикладу: екзепляр *first_animal.nickname - поверне *Simon , а *second_animal.nickname поверне *Murzyk
        
        
        self.weight = weight       # Створення поля *self.weight класу *class_Animal,
                                   # Такий запис означає що друге значення в екземплярі буде містити значення поля *weight
                                   # Це дозволяє для нашого екзепляра застосувати метод класу *.weight щоб отримати його значення.
            # Для нашого прикладу: екзепляр *first_animal.weight - поверне *10, а *second_animal.nickname поверне *12        

    def say(self):  # .say(self) - оголошення пустого методу класу ,(приклад що так можна робити, реалізацію методу можна буде дописати за потреби)
        pass

    def change_weight(self, weight): # Оголошення методу *.change_weight(weight) для зміни поля *weight в нашому класі *class_Animal,
                                     # Метод приймає один аргумент і міняє поле *weight в екземплярі до якого застосовується на
                                     # на значення аргументу що передається в методі в круглих дужках (*значення_на яке_хочемо_змінити_поле)
        
        self.weight = weight         # Такий запис означає що полю екземпляра *self.weight -
                                     # присвоїти значення *weight передане з методу *.change_weight(weight)
    
    def change_color(self, new_animal_color): # Метод який буде міняти значення поля *color класу , на значення передане методом *.change_color(*якесь_значення)
        Animal.color = new_animal_color       # такий запис міняє значення поля(зміної) класу , на значення яке передасть метод *.change_color(*якесь_значення)
        return new_animal_color               # Повертаємо змінене значення з класу. 
                                # Приклад : # Після застосовуння методу *.change_color("red") до хоча б одного екземпляра(*second_animal.change_color("red"))
                                            # стане  *first_animal.color - поверне *red і *second_animal.color поверне *red  


first_animal = Animal("Simon", 10,)  # Створення екземляру *first_animal з заданими полями *nickname і *weight
second_animal = Animal("Murzyk", 12) # Створення екземляру *second_animal з заданими полями *nickname і *weight

print(first_animal.color, second_animal.color ) # Принт для контролю результату # Виведе *white *white

second_animal.change_color("red")  # Застосування методу *.change_color("red") до екземпляру *second_animal

print(first_animal.color, second_animal.color ) # Принт для контролю результату, після застосування методу *.change_color("red") 
                                                # Виведе *red *red